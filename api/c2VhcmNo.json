[{"title":"You've Got to Find What You Love","date":"2019-07-28T13:15:06.000Z","updated":"2019-07-28T16:26:50.885Z","content":"I am honored to be with you today at your commencement from one of the finest universities in the world. I never graduated from college. Truth be told, this is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories.\nThe first story is about connecting the dots.I  dropped out of Reed College after the first 6 months, but then stayed  around as a drop-in for another 18 months or so before I really quit. So  why did I drop out?\nIt started before I was born. My biological mother was a young, unwed  college graduate student, and she decided to put me up for adoption.  She felt very strongly that I should be adopted by college graduates, so  everything was all set for me to be adopted at birth by a lawyer and  his wife. Except that when I popped out they decided at the last minute  that they really wanted a girl. So my parents, who were on a waiting  list, got a call in the middle of the night asking: “We have an  unexpected baby boy; do you want him?” They said: “Of course.” My  biological mother later found out that my mother had never graduated  from college and that my father had never graduated from high school.  She refused to sign the final adoption papers. She only relented a few  months later when my parents promised that I would someday go to  college.\nAnd 17 years later I did go to college. But I naively chose a college  that was almost as expensive as Stanford, and all of my working-class  parents’ savings were being spent on my college tuition. After six  months, I couldn’t see the value in it. I had no idea what I wanted to  do with my life and no idea how college was going to help me figure it  out. And here I was spending all of the money my parents had saved their  entire life. So I decided to drop out and trust that it would all work  out OK. It was pretty scary at the time, but looking back it was one of  the best decisions I ever made. The minute I dropped out I could stop  taking the required classes that didn’t interest me, and begin dropping  in on the ones that looked interesting.\nIt wasn’t all romantic. I didn’t have a dorm room, so I slept on the  floor in friends’ rooms, I returned Coke bottles for the 5? deposits to  buy food with, and I would walk the 7 miles across town every Sunday  night to get one good meal a week at the Hare Krishna temple. I loved  it. And much of what I stumbled into by following my curiosity and  intuition turned out to be priceless later on. Let me give you one  example:\nReed College at that time offered perhaps the best calligraphy  instruction in the country. Throughout the campus every poster, every  label on every drawer, was beautifully hand calligraphed. Because I had  dropped out and didn’t have to take the normal classes, I decided to  take a calligraphy class to learn how to do this. I learned about serif  and sans serif typefaces, about varying the amount of space between  different letter combinations, about what makes great typography great.  It was beautiful, historical, artistically subtle in a way that science  can’t capture, and I found it fascinating.\nNone of this had even a hope of any practical application in my life.  But 10 years later, when we were designing the first Macintosh  computer, it all came back to me. And we designed it all into the Mac.  It was the first computer with beautiful typography. If I had never  dropped in on that single course in college, the Mac would have never  had multiple typefaces or proportionally spaced fonts. And since Windows  just copied the Mac, it’s likely that no personal computer would have  them. If I had never dropped out, I would have never dropped in on this  calligraphy class, and personal computers might not have the wonderful  typography that they do. Of course it was impossible to connect the dots  looking forward when I was in college. But it was very, very clear  looking backward 10 years later.\nAgain, you can’t connect the dots looking forward; you can only  connect them looking backward. So you have to trust that the dots will  somehow connect in your future. You have to trust in something — your  gut, destiny, life, karma, whatever. This approach has never let me  down, and it has made all the difference in my life.\nMy second story is about love and loss.I  was lucky — I found what I loved to do early in life. Woz and I started  Apple in my parents’ garage when I was 20. We worked hard, and in 10  years Apple had grown from just the two of us in a garage into a $2  billion company with over 4,000 employees. We had just released our  finest creation — the Macintosh — a year earlier, and I had just turned  30. And then I got fired. How can you get fired from a company you  started? Well, as Apple grew we hired someone who I thought was very  talented to run the company with me, and for the first year or so things  went well. But then our visions of the future began to diverge and  eventually we had a falling out. When we did, our Board of Directors  sided with him. So at 30 I was out. And very publicly out. What had been  the focus of my entire adult life was gone, and it was devastating.\nI really didn’t know what to do for a few months. I felt that I had  let the previous generation of entrepreneurs down — that I had dropped  the baton as it was being passed to me. I met with David Packard and Bob  Noyce and tried to apologize for screwing up so badly. I was a very  public failure, and I even thought about running away from the valley.  But something slowly began to dawn on me — I still loved what I did. The  turn of events at Apple had not changed that one bit. I had been  rejected, but I was still in love. And so I decided to start over.\nI didn’t see it then, but it turned out that getting fired from Apple  was the best thing that could have ever happened to me. The heaviness  of being successful was replaced by the lightness of being a beginner  again, less sure about everything. It freed me to enter one of the most  creative periods of my life.\nDuring the next five years, I started a company named NeXT, another  company named Pixar, and fell in love with an amazing woman who would  become my wife. Pixar went on to create the world’s first computer  animated feature film, Toy Story, and is now the most successful  animation studio in the world. In a remarkable turn of events, Apple  bought NeXT, I returned to Apple, and the technology we developed at  NeXT is at the heart of Apple’s current renaissance. And Laurene and I  have a wonderful family together.\nI’m pretty sure none of this would have happened if I hadn’t been  fired from Apple. It was awful tasting medicine, but I guess the patient  needed it. Sometimes life hits you in the head with a brick. Don’t lose  faith. I’m convinced that the only thing that kept me going was that I  loved what I did. You’ve got to find what you love. And that is as true  for your work as it is for your lovers. Your work is going to fill a  large part of your life, and the only way to be truly satisfied is to do  what you believe is great work. And the only way to do great work is to  love what you do. If you haven’t found it yet, keep looking. Don’t  settle. As with all matters of the heart, you’ll know when you find it.  And, like any great relationship, it just gets better and better as the  years roll on. So keep looking until you find it. Don’t settle.\nMy third story is about death.When  I was 17, I read a quote that went something like: “If you live each  day as if it was your last, someday you’ll most certainly be right.” It  made an impression on me, and since then, for the past 33 years, I have  looked in the mirror every morning and asked myself: “If today were the  last day of my life, would I want to do what I am about to do today?”  And whenever the answer has been “No” for too many days in a row, I know  I need to change something.\nRemembering that I’ll be dead soon is the most important tool I’ve  ever encountered to help me make the big choices in life. Because almost  everything — all external expectations, all pride, all fear of  embarrassment or failure — these things just fall away in the face of  death, leaving only what is truly important. Remembering that you are  going to die is the best way I know to avoid the trap of thinking you  have something to lose. You are already naked. There is no reason not to  follow your heart.\nAbout a year ago I was diagnosed with cancer. I had a scan at 7:30 in  the morning, and it clearly showed a tumor on my pancreas. I didn’t  even know what a pancreas was. The doctors told me this was almost  certainly a type of cancer that is incurable, and that I should expect  to live no longer than three to six months. My doctor advised me to go  home and get my affairs in order, which is doctor’s code for prepare to  die. It means to try to tell your kids everything you thought you’d have  the next 10 years to tell them in just a few months. It means to make  sure everything is buttoned up so that it will be as easy as possible  for your family. It means to say your goodbyes.\nI lived with that diagnosis all day. Later that evening I had a  biopsy, where they stuck an endoscope down my throat, through my stomach  and into my intestines, put a needle into my pancreas and got a few  cells from the tumor. I was sedated, but my wife, who was there, told me  that when they viewed the cells under a microscope the doctors started  crying because it turned out to be a very rare form of pancreatic cancer  that is curable with surgery. I had the surgery and I’m fine now.\nThis was the closest I’ve been to facing death, and I hope it’s the  closest I get for a few more decades. Having lived through it, I can now  say this to you with a bit more certainty than when death was a useful  but purely intellectual concept:\nNo one wants to die. Even people who want to go to heaven don’t want  to die to get there. And yet death is the destination we all share. No  one has ever escaped it. And that is as it should be, because Death is  very likely the single best invention of Life. It is Life’s change  agent. It clears out the old to make way for the new. Right now the new  is you, but someday not too long from now, you will gradually become the  old and be cleared away. Sorry to be so dramatic, but it is quite true.\nYour time is limited, so don’t waste it living someone else’s life.  Don’t be trapped by dogma — which is living with the results of other  people’s thinking. Don’t let the noise of others’ opinions drown out  your own inner voice. And most important, have the courage to follow  your heart and intuition. They somehow already know what you truly want  to become. Everything else is secondary.\nWhen I was young, there was an amazing publication called The Whole  Earth Catalog, which was one of the bibles of my generation. It was  created by a fellow named Stewart Brand not far from here in Menlo Park,  and he brought it to life with his poetic touch. This was in the late  1960s, before personal computers and desktop publishing, so it was all  made with typewriters, scissors and Polaroid cameras. It was sort of  like Google in paperback form, 35 years before Google came along: It was  idealistic, and overflowing with neat tools and great notions.\nStewart and his team put out several issues of The Whole Earth  Catalog, and then when it had run its course, they put out a final  issue. It was the mid-1970s, and I was your age. On the back cover of  their final issue was a photograph of an early morning country road, the  kind you might find yourself hitchhiking on if you were so adventurous.  Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their  farewell message as they signed off. Stay Hungry. Stay Foolish. And I  have always wished that for myself. And now, as you graduate to begin  anew, I wish that for you.\nStay Hungry. Stay Foolish.Thank you all very much.原文拷贝自Elmore’blog\n","thumbnail":"https://i.loli.net/2019/07/28/5d3dc5e1f0acc24317.jpg","plink":"https://gmahsm.github.io/post/You've Got to Find What You Love/"},{"title":"【Mybatis】多表查询&SSM整合","date":"2019-09-10T01:34:25.000Z","updated":"2019-09-10T01:38:32.635Z","content":"1.Mybatis多表查询1.1 一对一查询1.1.1 一对一查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户\n一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户\n\n1.1.2一对一查询的语句对应的sql语句：select *  from orders o,user u where o.uid=u.id;\n查询的结果如下：\n\n1.1.3 创建Order和User实体123456789101112131415161718public class Order &#123;    private int id;    private Date ordertime;    private double total;    //代表当前订单从属于哪一个客户    private User user;&#125;public class User &#123;        private int id;    private String username;    private String password;    private Date birthday;&#125;\n\n1.1.4 创建OrderMapper接口123public interface OrderMapper &#123;    List&lt;Order&gt; findAll();&#125;\n\n1.1.5 配置OrderMapper.xml1234567891011&lt;mapper namespace=\"com.itheima.mapper.OrderMapper\"&gt;    &lt;resultMap id=\"orderMap\" type=\"com.itheima.domain.Order\"&gt;        &lt;result column=\"uid\" property=\"user.id\"&gt;&lt;/result&gt;        &lt;result column=\"username\" property=\"user.username\"&gt;&lt;/result&gt;        &lt;result column=\"password\" property=\"user.password\"&gt;&lt;/result&gt;        &lt;result column=\"birthday\" property=\"user.birthday\"&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;select id=\"findAll\" resultMap=\"orderMap\"&gt;        select * from orders o,user u where o.uid=u.id    &lt;/select&gt;&lt;/mapper&gt;\n\n其中还可以配置如下：\n1234567891011&lt;resultMap id=\"orderMap\" type=\"com.itheima.domain.Order\"&gt;    &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt;    &lt;result property=\"ordertime\" column=\"ordertime\"&gt;&lt;/result&gt;    &lt;result property=\"total\" column=\"total\"&gt;&lt;/result&gt;    &lt;association property=\"user\" javaType=\"com.itheima.domain.User\"&gt;        &lt;result column=\"uid\" property=\"id\"&gt;&lt;/result&gt;        &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt;        &lt;result column=\"password\" property=\"password\"&gt;&lt;/result&gt;        &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt;    &lt;/association&gt;&lt;/resultMap&gt;\n\n1.1.6 测试结果12345OrderMapper mapper = sqlSession.getMapper(OrderMapper.class);List&lt;Order&gt; all = mapper.findAll();for(Order order : all)&#123;    System.out.println(order);&#125;\n\n\n1.2 一对多查询1.2.1 一对多查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户\n一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单\n  \n1.2.2 一对多查询的语句对应的sql语句：select *,o.id oid from user u left join orders o on u.id=o.uid;\n查询的结果如下：\n\n1.2.3 修改User实体12345678910111213141516171819public class Order &#123;    private int id;    private Date ordertime;    private double total;    //代表当前订单从属于哪一个客户    private User user;&#125;public class User &#123;        private int id;    private String username;    private String password;    private Date birthday;    //代表当前用户具备哪些订单    private List&lt;Order&gt; orderList;&#125;\n\n1.2.4 创建UserMapper接口123public interface UserMapper &#123;    List&lt;User&gt; findAll();&#125;\n\n1.2.5 配置UserMapper.xml12345678910111213141516&lt;mapper namespace=\"com.itheima.mapper.UserMapper\"&gt;    &lt;resultMap id=\"userMap\" type=\"com.itheima.domain.User\"&gt;        &lt;result column=\"id\" property=\"id\"&gt;&lt;/result&gt;        &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt;        &lt;result column=\"password\" property=\"password\"&gt;&lt;/result&gt;        &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt;        &lt;collection property=\"orderList\" ofType=\"com.itheima.domain.Order\"&gt;            &lt;result column=\"oid\" property=\"id\"&gt;&lt;/result&gt;            &lt;result column=\"ordertime\" property=\"ordertime\"&gt;&lt;/result&gt;            &lt;result column=\"total\" property=\"total\"&gt;&lt;/result&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=\"findAll\" resultMap=\"userMap\"&gt;        select *,o.id oid from user u left join orders o on u.id=o.uid    &lt;/select&gt;&lt;/mapper&gt;\n\n1.2.6 测试结果12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAll();for(User user : all)&#123;    System.out.println(user.getUsername());    List&lt;Order&gt; orderList = user.getOrderList();    for(Order order : orderList)&#123;        System.out.println(order);    &#125;    System.out.println(\"----------------------------------\");&#125;\n\n\n1.3 多对多查询1.3.1 多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用\n多对多查询的需求：查询用户同时查询出该用户的所有角色\n\n1.3.2 多对多查询的语句对应的sql语句：select u.,r.,r.id rid from user u left join user_role ur on u.id=ur.user_id\n inner join role r on ur.role_id=r.id;\n查询的结果如下：\n\n1.3.3 创建Role实体，修改User实体1234567891011121314151617public class User &#123;    private int id;    private String username;    private String password;    private Date birthday;    //代表当前用户具备哪些订单    private List&lt;Order&gt; orderList;    //代表当前用户具备哪些角色    private List&lt;Role&gt; roleList;&#125;public class Role &#123;    private int id;    private String rolename;&#125;\n\n1.3.4  添加UserMapper接口方法1List&lt;User&gt; findAllUserAndRole();\n\n1.3.5 配置UserMapper.xml1234567891011121314&lt;resultMap id=\"userRoleMap\" type=\"com.itheima.domain.User\"&gt;    &lt;result column=\"id\" property=\"id\"&gt;&lt;/result&gt;    &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt;    &lt;result column=\"password\" property=\"password\"&gt;&lt;/result&gt;    &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt;    &lt;collection property=\"roleList\" ofType=\"com.itheima.domain.Role\"&gt;        &lt;result column=\"rid\" property=\"id\"&gt;&lt;/result&gt;        &lt;result column=\"rolename\" property=\"rolename\"&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"findAllUserAndRole\" resultMap=\"userRoleMap\"&gt;    select u.*,r.*,r.id rid from user u left join user_role ur on u.id=ur.user_id    inner join role r on ur.role_id=r.id&lt;/select&gt;\n\n1.3.6 测试结果12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAllUserAndRole();for(User user : all)&#123;    System.out.println(user.getUsername());    List&lt;Role&gt; roleList = user.getRoleList();    for(Role role : roleList)&#123;        System.out.println(role);    &#125;    System.out.println(\"----------------------------------\");&#125;\n\n\n1.4 知识小结MyBatis多表配置方式：\n一对一配置：使用做配置\n一对多配置：使用+做配置\n多对多配置：使用+做配置\n2.Mybatis的注解开发2.1 MyBatis的常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper\n映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。\n@Insert：实现新增\n@Update：实现更新\n@Delete：实现删除\n@Select：实现查询\n@Result：实现结果集封装\n@Results：可以与@Result 一起使用，封装多个结果集\n@One：实现一对一结果集封装\n@Many：实现一对多结果集封装\n2.2 MyBatis的增删改查我们完成简单的user表的增删改查的操作\n123456789101112131415161718192021222324252627282930313233343536373839404142434445private UserMapper userMapper;@Beforepublic void before() throws IOException &#123;    InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");    SqlSessionFactory sqlSessionFactory = new                  SqlSessionFactoryBuilder().build(resourceAsStream);    SqlSession sqlSession = sqlSessionFactory.openSession(true);    userMapper = sqlSession.getMapper(UserMapper.class);&#125;@Testpublic void testAdd() &#123;    User user = new User();    user.setUsername(\"测试数据\");    user.setPassword(\"123\");    user.setBirthday(new Date());    userMapper.add(user);&#125;@Testpublic void testUpdate() throws IOException &#123;    User user = new User();    user.setId(16);    user.setUsername(\"测试数据修改\");    user.setPassword(\"abc\");    user.setBirthday(new Date());    userMapper.update(user);&#125;@Testpublic void testDelete() throws IOException &#123;    userMapper.delete(16);&#125;@Testpublic void testFindById() throws IOException &#123;    User user = userMapper.findById(1);    System.out.println(user);&#125;@Testpublic void testFindAll() throws IOException &#123;    List&lt;User&gt; all = userMapper.findAll();    for(User user : all)&#123;        System.out.println(user);    &#125;&#125;\n\n修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可\n1234&lt;mappers&gt;    &lt;!--扫描使用注解的类--&gt;    &lt;mapper class=\"com.itheima.mapper.UserMapper\"&gt;&lt;/mapper&gt;&lt;/mappers&gt;\n\n或者指定扫描包含映射关系的接口所在的包也可以\n1234&lt;mappers&gt;    &lt;!--扫描使用注解的类所在的包--&gt;    &lt;package name=\"com.itheima.mapper\"&gt;&lt;/package&gt;&lt;/mappers&gt;\n\n2.3 MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置\n\n\n2.4 一对一查询2.4.1 一对一查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户\n一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户\n\n2.4.2 一对一查询的语句对应的sql语句：\n123select * from orders;select * from user where id=查询出订单的uid;\n\n查询的结果如下：\n\n2.4.3 创建Order和User实体123456789101112131415161718public class Order &#123;    private int id;    private Date ordertime;    private double total;    //代表当前订单从属于哪一个客户    private User user;&#125;public class User &#123;        private int id;    private String username;    private String password;    private Date birthday;&#125;\n\n2.4.4 创建OrderMapper接口123public interface OrderMapper &#123;    List&lt;Order&gt; findAll();&#125;\n\n2.4.5 使用注解配置Mapper123456789101112public interface OrderMapper &#123;    @Select(\"select * from orders\")    @Results(&#123;            @Result(id=true,property = \"id\",column = \"id\"),            @Result(property = \"ordertime\",column = \"ordertime\"),            @Result(property = \"total\",column = \"total\"),            @Result(property = \"user\",column = \"uid\",                    javaType = User.class,                    one = @One(select = \"com.itheima.mapper.UserMapper.findById\"))    &#125;)    List&lt;Order&gt; findAll();&#125;\n\n123456public interface UserMapper &#123;    @Select(\"select * from user where id=#&#123;id&#125;\")    User findById(int id);    &#125;\n\n2.4.6 测试结果1234567@Testpublic void testSelectOrderAndUser() &#123;    List&lt;Order&gt; all = orderMapper.findAll();    for(Order order : all)&#123;        System.out.println(order);    &#125;&#125;\n\n\n2.5 一对多查询2.5.1 一对多查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户\n一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单\n\n2.5.2 一对多查询的语句对应的sql语句：\n123select * from user;select * from orders where uid=查询出用户的id;\n\n查询的结果如下：\n\n2.5.3 修改User实体12345678910111213141516171819public class Order &#123;    private int id;    private Date ordertime;    private double total;    //代表当前订单从属于哪一个客户    private User user;&#125;public class User &#123;        private int id;    private String username;    private String password;    private Date birthday;    //代表当前用户具备哪些订单    private List&lt;Order&gt; orderList;&#125;\n\n2.5.4 创建UserMapper接口1List&lt;User&gt; findAllUserAndOrder();\n\n2.5.5 使用注解配置Mapper12345678910111213141516171819public interface UserMapper &#123;    @Select(\"select * from user\")    @Results(&#123;            @Result(id = true,property = \"id\",column = \"id\"),            @Result(property = \"username\",column = \"username\"),            @Result(property = \"password\",column = \"password\"),            @Result(property = \"birthday\",column = \"birthday\"),            @Result(property = \"orderList\",column = \"id\",                    javaType = List.class,                    many = @Many(select = \"com.itheima.mapper.OrderMapper.findByUid\"))    &#125;)    List&lt;User&gt; findAllUserAndOrder();&#125;public interface OrderMapper &#123;    @Select(\"select * from orders where uid=#&#123;uid&#125;\")    List&lt;Order&gt; findByUid(int uid);&#125;\n\n2.5.6 测试结果123456789List&lt;User&gt; all = userMapper.findAllUserAndOrder();for(User user : all)&#123;    System.out.println(user.getUsername());    List&lt;Order&gt; orderList = user.getOrderList();    for(Order order : orderList)&#123;        System.out.println(order);    &#125;    System.out.println(\"-----------------------------\");&#125;\n\n\n2.6 多对多查询2.6.1 多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用\n多对多查询的需求：查询用户同时查询出该用户的所有角色\n\n2.6.2 多对多查询的语句对应的sql语句：\n123select * from user;select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=用户的id\n\n查询的结果如下：\n\n2.6.3 创建Role实体，修改User实体1234567891011121314151617public class User &#123;    private int id;    private String username;    private String password;    private Date birthday;    //代表当前用户具备哪些订单    private List&lt;Order&gt; orderList;    //代表当前用户具备哪些角色    private List&lt;Role&gt; roleList;&#125;public class Role &#123;    private int id;    private String rolename;&#125;\n\n2.6.4 添加UserMapper接口方法1List&lt;User&gt; findAllUserAndRole();\n\n2.6.5 使用注解配置Mapper12345678910111213141516171819public interface UserMapper &#123;    @Select(\"select * from user\")    @Results(&#123;        @Result(id = true,property = \"id\",column = \"id\"),        @Result(property = \"username\",column = \"username\"),        @Result(property = \"password\",column = \"password\"),        @Result(property = \"birthday\",column = \"birthday\"),        @Result(property = \"roleList\",column = \"id\",                javaType = List.class,                many = @Many(select = \"com.itheima.mapper.RoleMapper.findByUid\"))&#125;)List&lt;User&gt; findAllUserAndRole();&#125;public interface RoleMapper &#123;    @Select(\"select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=#&#123;uid&#125;\")    List&lt;Role&gt; findByUid(int uid);&#125;\n\n2.6.6 测试结果12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAllUserAndRole();for(User user : all)&#123;    System.out.println(user.getUsername());    List&lt;Role&gt; roleList = user.getRoleList();    for(Role role : roleList)&#123;        System.out.println(role);    &#125;    System.out.println(\"----------------------------------\");&#125;\n\n\nSSM框架整合1.1 原始方式整合1.准备工作\n2.创建Maven工程\n3.导入Maven坐标参考：素材/配置文件/pom.xml文件\n4.编写实体类123456public class Account &#123;    private int id;    private String name;    private double money;    //省略getter和setter方法&#125;\n\n5.编写Mapper接口123456public interface AccountMapper &#123;    //保存账户数据    void save(Account account);    //查询账户数据    List&lt;Account&gt; findAll();&#125;\n\n6.编写Service接口1234public interface AccountService &#123;    void save(Account account); //保存账户数据    List&lt;Account&gt; findAll(); //查询账户数据&#125;\n\n7.编写Service接口实现123456789101112131415@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123;    public void save(Account account) &#123;        SqlSession sqlSession = MyBatisUtils.openSession();        AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class);        accountMapper.save(account);        sqlSession.commit();        sqlSession.close();    &#125;    public List&lt;Account&gt; findAll() &#123;        SqlSession sqlSession = MyBatisUtils.openSession();        AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class);        return accountMapper.findAll();    &#125;&#125;\n\n8.编写Controller123456789101112131415161718@Controllerpublic class AccountController &#123;    @Autowired    private AccountService accountService;    @RequestMapping(\"/save\")    @ResponseBody    public String save(Account account)&#123;        accountService.save(account);        return \"save success\";    &#125;    @RequestMapping(\"/findAll\")    public ModelAndView findAll()&#123;        ModelAndView modelAndView = new ModelAndView();        modelAndView.setViewName(\"accountList\");        modelAndView.addObject(\"accountList\",accountService.findAll());        return modelAndView;    &#125;&#125;\n\n9.编写添加页面1234567891011121314&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;保存账户信息表单&lt;/h1&gt;    &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/save.action\" method=\"post\"&gt;        用户名称&lt;input type=\"text\" name=\"name\"&gt;&lt;br/&gt;        账户金额&lt;input type=\"text\" name=\"money\"&gt;&lt;br/&gt;        &lt;input type=\"submit\" value=\"保存\"&gt;&lt;br/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n10.编写列表页面1234567891011121314&lt;table border=\"1\"&gt;    &lt;tr&gt;        &lt;th&gt;账户id&lt;/th&gt;        &lt;th&gt;账户名称&lt;/th&gt;        &lt;th&gt;账户金额&lt;/th&gt;    &lt;/tr&gt;    &lt;c:forEach items=\"$&#123;accountList&#125;\" var=\"account\"&gt;        &lt;tr&gt;            &lt;td&gt;$&#123;account.id&#125;&lt;/td&gt;            &lt;td&gt;$&#123;account.name&#125;&lt;/td&gt;            &lt;td&gt;$&#123;account.money&#125;&lt;/td&gt;        &lt;/tr&gt;    &lt;/c:forEach&gt;&lt;/table&gt;\n\n11.编写相应配置文件(文件参考目录：素材/配置文件)•Spring配置文件：applicationContext.xml\n•SprngMVC配置文件：spring-mvc.xml\n•MyBatis映射文件：AccountMapper.xml\n•MyBatis核心文件：sqlMapConfig.xml\n•数据库连接信息文件：jdbc.properties\n•Web.xml文件：web.xml\n•日志文件：[log4j.xml](\n12.测试添加账户\n13.测试账户列表\n1.2 Spring整合MyBatis1.整合思路\n2.将SqlSessionFactory配置到Spring容器中1234567891011121314&lt;!--加载jdbc.properties--&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;!--配置数据源--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt;    &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt;    &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt;    &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt;    &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/bean&gt;&lt;!--配置MyBatis的SqlSessionFactory--&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;    &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;    &lt;property name=\"configLocation\" value=\"classpath:sqlMapConfig.xml\"/&gt;&lt;/bean&gt;\n\n3.扫描Mapper，让Spring容器产生Mapper实现类1234&lt;!--配置Mapper扫描--&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;    &lt;property name=\"basePackage\" value=\"com.itheima.mapper\"/&gt;&lt;/bean&gt;\n\n4.配置声明式事务控制12345678910111213&lt;!--配置声明式事务控制--&gt;&lt;bean id=\"transacionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;    &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transacionManager\"&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=\"*\"/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;    &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"/&gt;    &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt;&lt;/aop:config&gt;\n\n5.修改Service实现类代码12345678910111213@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123;    @Autowired    private AccountMapper accountMapper;    public void save(Account account) &#123;        accountMapper.save(account);    &#125;    public List&lt;Account&gt; findAll() &#123;        return accountMapper.findAll();    &#125;&#125;\n\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【Mybatis】多表查询-SSM整合/"},{"title":"【Mybatis】动态SQL&核心配置文件","date":"2019-09-10T01:29:40.000Z","updated":"2019-09-10T01:33:34.583Z","content":"只需要写dao层接口，不需要写接口实现。Mybatis 框架会自动创建接口的动态代理对象。但是要满足规范\n\n\n\n1.Mybatis的Dao层实现1.1 传统开发方式1.1.1编写UserDao接口123public interface UserDao &#123;    List&lt;User&gt; findAll() throws IOException;&#125;\n\n1.1.2.编写UserDaoImpl实现123456789101112public class UserDaoImpl implements UserDao &#123;    public List&lt;User&gt; findAll() throws IOException &#123;        InputStream resourceAsStream =                     Resources.getResourceAsStream(\"SqlMapConfig.xml\");        SqlSessionFactory sqlSessionFactory = new                     SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\");        sqlSession.close();        return userList;    &#125;&#125;\n\n1.1.3 测试传统方式123456@Testpublic void testTraditionDao() throws IOException &#123;    UserDao userDao = new UserDaoImpl();    List&lt;User&gt; all = userDao.findAll();    System.out.println(all);&#125;\n\n1.2 代理开发方式1.2.1 代理开发方式介绍采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。\nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\nMapper 接口开发需要遵循以下规范：\n1) Mapper.xml文件中的namespace与mapper接口的全限定名相同\n2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同\n3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同\n4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n1.2.2 编写UserMapper接口\n1.2.3测试代理方式1234567891011@Testpublic void testProxyDao() throws IOException &#123;    InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);    SqlSession sqlSession = sqlSessionFactory.openSession();    //获得MyBatis框架生成的UserMapper接口的实现类  UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    User user = userMapper.findById(1);    System.out.println(user);    sqlSession.close();&#125;\n\n1.3 知识小结MyBatis的Dao层实现的两种方式：\n手动对Dao进行实现：传统开发方式\n代理方式对Dao进行实现：\n1**UserMapper userMapper = sqlSession.getMapper(UserMapper.class);**\n\n2.MyBatis映射文件深入2.1 动态sql语句2.1.1动态sql语句概述Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。\n参考的官方文档，描述如下：\n\n2.1.2动态 SQL  之&lt;if&gt;我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。\n1234567891011&lt;select id=\"findByCondition\" parameterType=\"user\" resultType=\"user\"&gt;    select * from User    &lt;where&gt;        &lt;if test=\"id!=0\"&gt;            and id=#&#123;id&#125;        &lt;/if&gt;        &lt;if test=\"username!=null\"&gt;            and username=#&#123;username&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n当查询条件id和username都存在时，控制台打印的sql语句如下：\n12345678   … … …   //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);  User condition = new User();  condition.setId(1);  condition.setUsername(\"lucy\");  User user = userMapper.findByCondition(condition);  … … …\n\n\n当查询条件只有id存在时，控制台打印的sql语句如下：\n1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User condition = new User();condition.setId(1);User user = userMapper.findByCondition(condition);… … …\n\n\n2.1.3 动态 SQL  之&lt;foreach&gt;循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。\n12345678&lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt;    select * from User    &lt;where&gt;        &lt;foreach collection=\"array\" open=\"id in(\" close=\")\" item=\"id\" separator=\",\"&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n测试代码片段如下：\n1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);int[] ids = new int[]&#123;2,5&#125;;List&lt;User&gt; userList = userMapper.findByIds(ids);System.out.println(userList);… … …\n\n\nforeach标签的属性含义如下：\n标签用于遍历集合，它的属性：\n•collection：代表要遍历的集合元素，注意编写时不要写#{}\n•open：代表语句的开始部分\n•close：代表结束部分\n•item：代表遍历集合的每个元素，生成的变量名\n•sperator：代表分隔符s\n2.2 SQL片段抽取Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的\n12345678910111213&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=\"selectUser\" select * from User&lt;/sql&gt;&lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\"&gt;    &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; where id=#&#123;id&#125;&lt;/select&gt;&lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt;    &lt;include refid=\"selectUser\"&gt;&lt;/include&gt;    &lt;where&gt;        &lt;foreach collection=\"array\" open=\"id in(\" close=\")\" item=\"id\" separator=\",\"&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n2.3 知识小结MyBatis映射文件配置：\n12345678&lt;select&gt;：查询&lt;insert&gt;：插入&lt;update&gt;：修改&lt;delete&gt;：删除&lt;where&gt;：where条件&lt;if&gt;：if判断&lt;foreach&gt;：循环&lt;sql&gt;：sql片段抽取\n\n3. MyBatis核心配置文件深入3.1typeHandlers标签无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。\n\n你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。\n开发步骤：\n①定义转换类继承类BaseTypeHandler\n②覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法\n③在MyBatis核心配置文件中进行注册\n测试转换是否正确\n1234567891011121314public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123;    public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType type) &#123;        preparedStatement.setString(i,date.getTime()+\"\");    &#125;    public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123;        return new Date(resultSet.getLong(s));    &#125;    public Date getNullableResult(ResultSet resultSet, int i) throws SQLException &#123;        return new Date(resultSet.getLong(i));    &#125;    public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123;        return callableStatement.getDate(i);    &#125;&#125;\n\n1234&lt;!--注册类型自定义转换器--&gt;&lt;typeHandlers&gt;    &lt;typeHandler handler=\"com.itheima.typeHandlers.MyDateTypeHandler\"&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt;\n\n测试添加操作：\n12user.setBirthday(new Date());userMapper.add2(user);\n\n数据库数据：\n\n测试查询操作：\n​    \n\n3.2 plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据\n开发步骤：\n①导入通用PageHelper的坐标\n②在mybatis核心配置文件中配置PageHelper插件\n③测试分页数据获取\n①导入通用PageHelper坐标1234567891011&lt;!-- 分页助手 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;3.7.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;    &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;    &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;\n\n②在mybatis核心配置文件中配置PageHelper插件12345&lt;!-- 注意：分页助手的插件  配置在通用馆mapper之前 --&gt;&lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt;    &lt;!-- 指定方言 --&gt;    &lt;property name=\"dialect\" value=\"mysql\"/&gt;&lt;/plugin&gt;\n\n③测试分页代码实现12345678910@Testpublic void testPageHelper()&#123;    //设置分页参数    PageHelper.startPage(1,2);    List&lt;User&gt; select = userMapper2.select(null);    for(User user : select)&#123;        System.out.println(user);    &#125;&#125;\n\n获得分页相关的其他参数\n12345678//其他分页的数据PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select);System.out.println(\"总条数：\"+pageInfo.getTotal());System.out.println(\"总页数：\"+pageInfo.getPages());System.out.println(\"当前页：\"+pageInfo.getPageNum());System.out.println(\"每页显示长度：\"+pageInfo.getPageSize());System.out.println(\"是否第一页：\"+pageInfo.isIsFirstPage());System.out.println(\"是否最后一页：\"+pageInfo.isIsLastPage());\n\n3.3 知识小结MyBatis核心配置文件常用标签：\n1、properties标签：该标签可以加载外部的properties文件\n2、typeAliases标签：设置类型别名\n3、environments标签：数据源环境配置标签\n4、typeHandlers标签：配置自定义类型处理器\n5、plugins标签：配置MyBatis的插件\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【Mybatis】动态SQL-核心配置文件/"},{"title":"【Mybatis】入门","date":"2019-09-10T01:26:10.000Z","updated":"2019-09-10T01:27:56.754Z","content":"原始JDBC操作弊端：\n\n数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能\nsql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。\n查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置\n\n\n\n1.Mybatis简介1.1原始jdbc操作（查询数据）\n1.2原始jdbc操作（插入数据）\n1.3 原始jdbc操作的分析原始jdbc开发存在的问题如下：\n①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能\n②sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。\n③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置\n应对上述问题给出的解决方案：\n①使用数据库连接池初始化连接资源\n②将sql语句抽取到xml配置文件中\n③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射\n1.4 什么是Mybatismybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。\nmybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。\n最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。\n2.Mybatis的快速入门2.1 MyBatis开发步骤MyBatis官网地址：http://www.mybatis.org/mybatis-3/ \n\nMyBatis开发步骤：\n①添加MyBatis的坐标\n②创建user数据表\n③编写User实体类 \n④编写映射文件UserMapper.xml\n⑤编写核心文件SqlMapConfig.xml\n⑥编写测试类\n2.2 环境搭建1)导入MyBatis的坐标和其他相关坐标\n1234567891011121314151617181920212223242526&lt;!--mybatis坐标--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;       &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.6&lt;/version&gt;        &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志坐标--&gt;&lt;dependency&gt;        &lt;groupId&gt;log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;\n\n2)  创建user数据表\n\n3) 编写User实体\n123456public class User &#123;    \tprivate int id;    \tprivate String username;    \tprivate String password;    //省略get个set方法&#125;\n\n4)编写UserMapper映射文件\n123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper        \tPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"        \t\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"userMapper\"&gt;    \t&lt;select id=\"findAll\" resultType=\"com.itheima.domain.User\"&gt;        \t\tselect * from User    \t&lt;/select&gt;&lt;/mapper&gt;\n\n5) 编写MyBatis核心文件\n123456789101112131415161718&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN“ \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    \t&lt;environments default=\"development\"&gt;        \t\t&lt;environment id=\"development\"&gt;            \t\t\t&lt;transactionManager type=\"JDBC\"/&gt;            \t\t\t&lt;dataSource type=\"POOLED\"&gt;                \t\t\t\t&lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt;\t\t\t\t&lt;property name=\"url\" value=\"jdbc:mysql:///test\"/&gt;                \t\t\t\t&lt;property name=\"username\" value=\"root\"/&gt;\t\t\t\t&lt;property name=\"password\" value=\"root\"/&gt;            \t\t\t&lt;/dataSource&gt;        \t\t&lt;/environment&gt;    \t&lt;/environments&gt;    \t\t&lt;mappers&gt; \t\t&lt;mapper resource=\"com/itheima/mapper/UserMapper.xml\"/&gt; \t&lt;/mappers&gt;&lt;/configuration&gt;\n\n2.3 编写测试代码12345678910111213//加载核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");//获得sqlSession工厂对象SqlSessionFactory sqlSessionFactory = new                                       SqlSessionFactoryBuilder().build(resourceAsStream);//获得sqlSession对象SqlSession sqlSession = sqlSessionFactory.openSession();//执行sql语句List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\");//打印结果System.out.println(userList);//释放资源sqlSession.close();\n\n2.4 知识小结MyBatis开发步骤：\n①添加MyBatis的坐标\n②创建user数据表\n③编写User实体类 \n④编写映射文件UserMapper.xml\n⑤编写核心文件SqlMapConfig.xml\n⑥编写测试类\n3. MyBatis的映射文件概述\n4. MyBatis的增删改查操作4.1 MyBatis的插入数据操作1)编写UserMapper映射文件\n12345&lt;mapper namespace=\"userMapper\"&gt;    \t&lt;insert id=\"add\" parameterType=\"com.itheima.domain.User\"&gt;        \t\tinsert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)    \t&lt;/insert&gt;&lt;/mapper&gt;\n\n2)编写插入实体User的代码\n123456789InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new                         SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert(\"userMapper.add\", user);System.out.println(insert);//提交事务sqlSession.commit();sqlSession.close();\n\n3)插入操作注意问题\n• 插入语句使用insert标签\n• 在映射文件中使用parameterType属性指定要插入的数据类型\n•Sql语句中使用#{实体属性名}方式引用实体中的属性值\n•插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象);\n•插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() \n4.2 MyBatis的修改数据操作1)编写UserMapper映射文件\n12345&lt;mapper namespace=\"userMapper\"&gt;    &lt;update id=\"update\" parameterType=\"com.itheima.domain.User\"&gt;        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;\n\n2)编写修改实体User的代码\n1234567InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update(\"userMapper.update\", user);System.out.println(update);sqlSession.commit();sqlSession.close();\n\n3)修改操作注意问题\n• 修改语句使用update标签\n• 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象);\n4.3 MyBatis的删除数据操作1)编写UserMapper映射文件\n12345&lt;mapper namespace=\"userMapper\"&gt;    &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt;        delete from user where id=#&#123;id&#125;    &lt;/delete&gt;&lt;/mapper&gt;\n\n2)编写删除数据的代码\n1234567InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int delete = sqlSession.delete(\"userMapper.delete\",3);System.out.println(delete);sqlSession.commit();sqlSession.close();\n\n3)删除操作注意问题\n• 删除语句使用delete标签\n•Sql语句中使用#{任意字符串}方式引用传递的单个参数\n•删除操作使用的API是sqlSession.delete(“命名空间.id”,Object);\n4.4 知识小结1234567891011121314151617增删改查映射配置与API：查询数据： List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\");    &lt;select id=\"findAll\" resultType=\"com.itheima.domain.User\"&gt;        select * from User    &lt;/select&gt;添加数据： sqlSession.insert(\"userMapper.add\", user);    &lt;insert id=\"add\" parameterType=\"com.itheima.domain.User\"&gt;        insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)    &lt;/insert&gt;修改数据： sqlSession.update(\"userMapper.update\", user);    &lt;update id=\"update\" parameterType=\"com.itheima.domain.User\"&gt;        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;    &lt;/update&gt;删除数据：sqlSession.delete(\"userMapper.delete\",3);    &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt;        delete from user where id=#&#123;id&#125;    &lt;/delete&gt;\n\n5. MyBatis核心配置文件概述5.1 MyBatis核心配置文件层级关系\n5.2 MyBatis常用配置解析1)environments标签\n数据库环境的配置，支持多环境配置\n\n其中，事务管理器（transactionManager）类型有两种：\n•JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。\n•MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。\n其中，数据源（dataSource）类型有三种：\n•UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。\n•POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。\n•JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。\n2)mapper标签\n该标签的作用是加载映射的，加载方式有如下几种：\n•使用相对于类路径的资源引用，例如：\n\n\n•使用完全限定资源定位符（URL），例如：\n\n\n•使用映射器接口实现类的完全限定类名，例如：\n\n\n•将包内的映射器接口实现全部注册为映射器，例如：\n\n\n3)Properties标签\n实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件\n  \n4)typeAliases标签\n类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下\n\n配置typeAliases，为com.itheima.domain.User定义别名为user\n\n上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名\n\n5.3 知识小结核心配置文件常用配置：\nproperties标签：该标签可以加载外部的properties文件\n1&lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt;\n\ntypeAliases标签：设置类型别名\n1&lt;typeAlias type=\"com.itheima.domain.User\" alias=\"user\"&gt;&lt;/typeAlias&gt;\n\nmappers标签：加载映射配置\n1&lt;mapper resource=\"com/itheima/mapper/UserMapping.xml\"&gt;&lt;/mapper&gt;\n\nenvironments标签：数据源环境配置标签\n\n6.MyBatis相应API6.1 SqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactory  build(InputStream inputStream)\n通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象\n1234String resource = \"org/mybatis/builder/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream);\n\n其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。\n6.2 SqlSession工厂对象SqlSessionFactorySqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个：\n\n6.3 SqlSession会话对象SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。\n执行语句的方法主要有：\n12345&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter)\n\n操作事务的方法主要有：\n12void commit()  void rollback()\n\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【Mybatis】入门/"},{"title":"【SpringMVC】文件上传&拦截器&异常处理","date":"2019-09-03T03:53:49.000Z","updated":"2019-09-03T03:54:34.843Z","content":"SpringMVC的文件上传1-SpringMVC的请求-文件上传-客户端表单实现(应用)文件上传客户端表单需要满足：\n表单项type=“file”\n表单的提交方式是post\n表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data”\n12345&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/quick22\" method=\"post\" enctype=\"multipart/form-data\"&gt;        名称&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt;        文件1&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt;        &lt;input type=\"submit\" value=\"提交\"&gt;    &lt;/form&gt;\n\n2-SpringMVC的请求-文件上传-文件上传的原理(理解)\n3-SpringMVC的请求-文件上传-单文件上传的代码实现1(应用)添加依赖\n12345678910&lt;dependency&gt;      &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;      &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;      &lt;version&gt;1.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-io&lt;/groupId&gt;      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;      &lt;version&gt;2.3&lt;/version&gt;    &lt;/dependency&gt;\n\n配置多媒体解析器\n12345&lt;!--配置文件上传解析器--&gt;    &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;        &lt;property name=\"defaultEncoding\" value=\"UYF-8\"/&gt;        &lt;property name=\"maxUploadSize\" value=\"500000\"/&gt;    &lt;/bean&gt;\n\n后台程序\n123456@RequestMapping(value=\"/quick22\")    @ResponseBody    public void save22(String username, MultipartFile uploadFile) throws IOException &#123;        System.out.println(username);       \tSystem.out.println(uploadFile);    &#125;\n\n4-SpringMVC的请求-文件上传-单文件上传的代码实现2(应用)完成文件上传\n12345678@RequestMapping(value=\"/quick22\")    @ResponseBody    public void save22(String username, MultipartFile uploadFile) throws IOException &#123;        System.out.println(username);        //获得上传文件的名称        String originalFilename = uploadFile.getOriginalFilename();        uploadFile.transferTo(new File(\"C:\\\\upload\\\\\"+originalFilename));    &#125;\n\n5-SpringMVC的请求-文件上传-多文件上传的代码实现(应用)多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可\n123456&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/quick23\" method=\"post\" enctype=\"multipart/form-data\"&gt;        名称&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt;        文件1&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt;        文件2&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt;        &lt;input type=\"submit\" value=\"提交\"&gt;    &lt;/form&gt;\n\n123456789@RequestMapping(value=\"/quick23\")    @ResponseBody    public void save23(String username, MultipartFile[] uploadFile) throws IOException &#123;        System.out.println(username);        for (MultipartFile multipartFile : uploadFile) &#123;            String originalFilename = multipartFile.getOriginalFilename();            multipartFile.transferTo(new File(\"C:\\\\upload\\\\\"+originalFilename));        &#125;    &#125;\n\n6-SpringMVC的请求-知识要点(理解，记忆)\nSpringMVC的拦截器01-SpringMVC拦截器-拦截器的作用(理解)Spring MVC 的拦截器类似于 Servlet  开发中的过滤器 Filter，用于对处理器进行预处理和后处理。\n将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。\n02-SpringMVC拦截器-interceptor和filter区别(理解，记忆)关于interceptor和filter的区别，如图所示：\n\n03-SpringMVC拦截器-快速入门(应用)自定义拦截器很简单，只有如下三步：\n①创建拦截器类实现HandlerInterceptor接口\n②配置拦截器\n③测试拦截器的拦截效果\n编写拦截器：\n1234567891011121314public class MyInterceptor1 implements HandlerInterceptor &#123;    //在目标方法执行之前 执行    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;        System.out.println(\"preHandle.....\");&#125;    //在目标方法执行之后 视图对象返回之前执行    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;System.out.println(\"postHandle...\");    &#125;    //在流程都执行完毕后 执行    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;        System.out.println(\"afterCompletion....\");    &#125;&#125;\n\n配置：在SpringMVC的配置文件中配置\n12345678&lt;!--配置拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!--对哪些资源执行拦截操作--&gt;            &lt;mvc:mapping path=\"/**\"/&gt;            &lt;bean class=\"com.itheima.interceptor.MyInterceptor1\"/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;\n\n编写测试程序测试：\n编写Controller,发请求到controller,跳转页面\n12345678910111213@Controllerpublic class TargetController &#123;    @RequestMapping(\"/target\")    public ModelAndView show()&#123;        System.out.println(\"目标资源执行......\");        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(\"name\",\"itcast\");        modelAndView.setViewName(\"index\");        return modelAndView;    &#125;&#125;\n\n页面\n12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World! $&#123;name&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;\n\n04-SpringMVC拦截器-快速入门详解(应用)拦截器在预处理后什么情况下会执行目标资源，什么情况下不执行目标资源，以及在有多个拦截器的情况下拦截器的执行顺序是什么?\n再编写一个拦截器2，\n1234567891011121314151617public class MyInterceptor2 implements HandlerInterceptor &#123;    //在目标方法执行之前 执行    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;        System.out.println(\"preHandle22222.....\");        return true;    &#125;    //在目标方法执行之后 视图对象返回之前执行    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;        System.out.println(\"postHandle2222...\");    &#125;    //在流程都执行完毕后 执行    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;        System.out.println(\"afterCompletion2222....\");    &#125;&#125;\n\n配置拦截器2\n12345678910111213&lt;!--配置拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!--对哪些资源执行拦截操作--&gt;            &lt;mvc:mapping path=\"/**\"/&gt;            &lt;bean class=\"com.itheima.interceptor.MyInterceptor2\"/&gt;        &lt;/mvc:interceptor&gt;        &lt;mvc:interceptor&gt;            &lt;!--对哪些资源执行拦截操作--&gt;            &lt;mvc:mapping path=\"/**\"/&gt;            &lt;bean class=\"com.itheima.interceptor.MyInterceptor1\"/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;\n\n结论：\n当拦截器的preHandle方法返回true则会执行目标资源，如果返回false则不执行目标资源\n多个拦截器情况下，配置在前的先执行，配置在后的后执行\n拦截器中的方法执行顺序是：preHandler——-目标资源—-postHandle—- afterCompletion\n05-SpringMVC拦截器-知识小结(记忆)拦截器中的方法说明如下\n\n06-SpringMVC拦截器-用户登录权限控制分析(理解)在day06-Spring练习案例的基础之上：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作\n需求图：\n\n07-SpringMVC拦截器-用户登录权限控制代码实现1(应用)判断用户是否登录  本质：判断session中有没有user，如果没有登陆则先去登陆，如果已经登陆则直接放行访问目标资源\n先编写拦截器如下：\n1234567891011121314public class PrivilegeInterceptor implements HandlerInterceptor &#123;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123;        //逻辑：判断用户是否登录  本质：判断session中有没有user        HttpSession session = request.getSession();        User user = (User) session.getAttribute(\"user\");        if(user==null)&#123;            //没有登录            response.sendRedirect(request.getContextPath()+\"/login.jsp\");            return false;        &#125;        //放行  访问目标资源        return true;    &#125;&#125;\n\n然后配置该拦截器：找到项目案例的spring-mvc.xml，添加如下配置：\n12345678&lt;!--配置权限拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!--配置对哪些资源执行拦截操作--&gt;            &lt;mvc:mapping path=\"/**\"/&gt;            &lt;bean class=\"com.itheima.interceptor.PrivilegeInterceptor\"/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;\n\n08-SpringMVC拦截器-用户登录权限控制代码实现2(应用)在登陆页面输入用户名密码，点击登陆，通过用户名密码进行查询，如果登陆成功，则将用户信息实体存入session，然后跳转到首页，如果登陆失败则继续回到登陆页面\n在UserController中编写登陆逻辑\n12345678910@RequestMapping(\"/login\")    public String login(String username,String password,HttpSession session)&#123;        User user = userService.login(username,password);        if(user!=null)&#123;            //登录成功  将user存储到session            session.setAttribute(\"user\",user);            return \"redirect:/index.jsp\";        &#125;        return \"redirect:/login.jsp\";    &#125;\n\nservice层代码如下：\n12345//service层public User login(String username, String password) &#123;            User user = userDao.findByUsernameAndPassword(username,password);            return user;&#125;\n\ndao层代码如下：\n12345//dao层 public User findByUsernameAndPassword(String username, String password) throws EmptyResultDataAccessException&#123;        User user = jdbcTemplate.queryForObject(\"select * from sys_user where username=? and password=?\", new BeanPropertyRowMapper&lt;User&gt;(User.class), username, password);        return user;    &#125;\n\n此时仍然登陆不上，因为我们需要将登陆请求url让拦截器放行,添加资源排除的配置\n12345678910&lt;!--配置权限拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!--配置对哪些资源执行拦截操作--&gt;            &lt;mvc:mapping path=\"/**\"/&gt;            &lt;!--配置哪些资源排除拦截操作--&gt;            &lt;mvc:exclude-mapping path=\"/user/login\"/&gt;            &lt;bean class=\"com.itheima.interceptor.PrivilegeInterceptor\"/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;\n\n09-SpringMVC拦截器-用户登录权限控制代码实现3(应用)JdbcTemplate.queryForObject对象如果查询不到数据会抛异常，导致程序无法达到预期效果，如何来解决该问题？\n在业务层处理来自dao层的异常，如果出现异常service层返回null,而不是将异常抛给controller\n因此改造登陆的业务层代码,添加异常的控制\n12345678public User login(String username, String password) &#123;        try &#123;            User user = userDao.findByUsernameAndPassword(username,password);            return user;        &#125;catch (EmptyResultDataAccessException e)&#123;            return null;        &#125;    &#125;\n\nSpringMVC异常处理机制1.1 异常处理的思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。\n系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图：\n\n1.2 异常处理两种方式① 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver\n② 实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器\n1.3 简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置\n123456789&lt;!--配置简单映射异常处理器--&gt;    &lt;bean class=“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”&gt;    &lt;property name=“defaultErrorView” value=“error”/&gt;   默认错误视图    &lt;property name=“exceptionMappings”&gt;        &lt;map&gt;\t\t异常类型\t\t                             错误视图            &lt;entry key=\"com.itheima.exception.MyException\" value=\"error\"/&gt;            &lt;entry key=\"java.lang.ClassCastException\" value=\"error\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n1.4 自定义异常处理步骤①创建异常处理器类实现HandlerExceptionResolver\n1234567891011public class MyExceptionResolver implements HandlerExceptionResolver &#123;@Overridepublic ModelAndView resolveException(HttpServletRequest request,     HttpServletResponse response, Object handler, Exception ex) &#123;    //处理异常的代码实现    //创建ModelAndView对象    ModelAndView modelAndView = new ModelAndView();     modelAndView.setViewName(\"exceptionPage\");    return modelAndView;    &#125;&#125;\n\n②配置异常处理器\n12&lt;bean id=\"exceptionResolver\"              class=\"com.itheima.exception.MyExceptionResolver\"/&gt;\n\n③编写异常页面\n123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;\t&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\t这是一个最终异常的显示页面&lt;/body&gt;&lt;/html&gt;\n\n④测试异常跳转\n123456@RequestMapping(\"/quick22\")@ResponseBodypublic void quickMethod22() throws IOException, ParseException &#123;    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");     simpleDateFormat.parse(\"abcde\");&#125;\n\n1.5 知识要点异常处理方式\n123配置简单异常处理器SimpleMappingExceptionResolver自定义异常处理器\n\n自定义异常处理步骤\n1234567①创建异常处理器类实现HandlerExceptionResolver②配置异常处理器③编写异常页面④测试异常跳转\n\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【SpringMVC】文件上传-拦截器-异常处理/"},{"title":"【SpringMVC】请求&响应","date":"2019-09-03T03:51:54.000Z","updated":"2019-09-03T03:58:27.496Z","content":"SpringMVC的请求和响应SpringMVC的数据响应01-SpringMVC的数据响应-数据响应方式(理解)1)    页面跳转\n直接返回字符串\n通过ModelAndView对象返回\n2） 回写数据 \n直接返回字符串\n返回对象或集合    \n02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用）\n03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)在Controller中方法返回ModelAndView对象，并且设置视图名称\n1234567891011121314@RequestMapping(value=\"/quick2\")    public ModelAndView save2()&#123;        /*            Model:模型 作用封装数据            View：视图 作用展示数据         */        ModelAndView modelAndView = new ModelAndView();        //设置模型数据        modelAndView.addObject(\"username\",\"itcast\");        //设置视图名称        modelAndView.setViewName(\"success\");        return modelAndView;    &#125;\n\n04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面\n1234567891011 @RequestMapping(value=\"/quick3\")    public ModelAndView save3(ModelAndView modelAndView)&#123;        modelAndView.addObject(\"username\",\"itheima\");        modelAndView.setViewName(\"success\");        return modelAndView;    &#125;@RequestMapping(value=\"/quick4\")    public String save4(Model model)&#123;        model.addAttribute(\"username\",\"博学谷\");        return \"success\";    &#125;\n\n05-SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可\n12345@RequestMapping(value=\"/quick5\")    public String save5(HttpServletRequest request)&#123;        request.setAttribute(\"username\",\"酷丁鱼\");        return \"success\";    &#125;\n\n06-SpringMVC的数据响应-回写数据-直接回写字符串(应用)通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void\n将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回\n12345678910@RequestMapping(value=\"/quick7\")    @ResponseBody  //告知SpringMVC框架 不进行视图跳转 直接进行数据响应    public String save7() throws IOException &#123;        return \"hello itheima\";    &#125;    @RequestMapping(value=\"/quick6\")    public void save6(HttpServletResponse response) throws IOException &#123;        response.getWriter().print(\"hello itcast\");    &#125;\n\n07-SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)12345@RequestMapping(value=\"/quick8\")    @ResponseBody    public String save8() throws IOException &#123;        return \"&#123;\\\"username\\\":\\\"zhangsan\\\",\\\"age\\\":18&#125;\";    &#125;\n\n手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串\n123456789101112@RequestMapping(value=\"/quick9\")    @ResponseBody    public String save9() throws IOException &#123;        User user = new User();        user.setUsername(\"lisi\");        user.setAge(30);        //使用json的转换工具将对象转换成json格式字符串在返回        ObjectMapper objectMapper = new ObjectMapper();        String json = objectMapper.writeValueAsString(user);        return json;    &#125;\n\n08-SpringMVC的数据响应-回写数据-返回对象或集合(应用)通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置：\n1234567&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt;        &lt;property name=\"messageConverters\"&gt;            &lt;list&gt;                &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;\n\n123456789@RequestMapping(value=\"/quick10\")    @ResponseBody    //期望SpringMVC自动将User转换成json格式的字符串    public User save10() throws IOException &#123;        User user = new User();        user.setUsername(\"lisi2\");        user.setAge(32);        return user;    &#125;\n\n09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置\n1&lt;mvc:annotation-driven/&gt;\n\n在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。\n使用&lt;mvc:annotation-driven /&gt;自动加载 RequestMappingHandlerMapping（处理映射器）和\nRequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用\n&lt;mvc:annotation-driven /&gt;替代注解处理器和适配器的配置。\n同时使用&lt;mvc:annotation-driven /&gt;\n默认底层就会集成jackson进行对象或集合的json格式字符串的转换\n10-SpringMVC的数据响应-知识要点小结(理解，记忆)1） 页面跳转\n直接返回字符串\n通过ModelAndView对象返回\n2） 回写数据 \n直接返回字符串\nHttpServletResponse 对象直接写回数据，HttpServletRequest对象带回数据，Model对象带回数据或者@ResponseBody将字符串数据写回\n返回对象或集合 \n@ResponseBody+&lt;mvc:annotation-driven/&gt;\nSpringMVC的请求11-SpringMVC的请求-获得请求参数-请求参数类型(理解)客户端请求参数的格式是：name=value&amp;name=value……\n服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数\n基本类型参数\nPOJO类型参数\n数组类型参数\n集合类型参数\n12-SpringMVC的请求-获得请求参数-获得基本类型参数(应用)Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换；\n自动的类型转换是指从String向其他类型的转换\nhttp://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12\n123456@RequestMapping(value=\"/quick11\")    @ResponseBody    public void save11(String username,int age) throws IOException &#123;        System.out.println(username);        System.out.println(age);    &#125;\n\n13-SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。\n12345678910111213141516171819202122232425262728293031package com.itheima.domain;public class User &#123;    private String username;    private int age;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return \"User&#123;\" +                \"username='\" + username + '\\'' +                \", age=\" + age +                '&#125;';    &#125;&#125;\n\n12345@RequestMapping(value=\"/quick12\")    @ResponseBody    public void save12(User user) throws IOException &#123;        System.out.println(user);    &#125;\n\n14-SpringMVC的请求-获得请求参数-获得数组类型参数(应用)Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。\n12345@RequestMapping(value=\"/quick13\")    @ResponseBody    public void save13(String[] strs) throws IOException &#123;        System.out.println(Arrays.asList(strs));    &#125;\n\n15-SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)获得集合参数时，要将集合参数包装到一个POJO中才可以。\n12345678&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/quick14\" method=\"post\"&gt;        &lt;%--表明是第一个User对象的username age--%&gt;        &lt;input type=\"text\" name=\"userList[0].username\"&gt;&lt;br/&gt;        &lt;input type=\"text\" name=\"userList[0].age\"&gt;&lt;br/&gt;        &lt;input type=\"text\" name=\"userList[1].username\"&gt;&lt;br/&gt;        &lt;input type=\"text\" name=\"userList[1].age\"&gt;&lt;br/&gt;        &lt;input type=\"submit\" value=\"提交\"&gt;    &lt;/form&gt;\n\n1234567891011121314151617181920212223package com.itheima.domain;import java.util.List;public class VO &#123;    private List&lt;User&gt; userList;    public List&lt;User&gt; getUserList() &#123;        return userList;    &#125;    public void setUserList(List&lt;User&gt; userList) &#123;        this.userList = userList;    &#125;    @Override    public String toString() &#123;        return \"VO&#123;\" +                \"userList=\" + userList +                '&#125;';    &#125;&#125;\n\n12345@RequestMapping(value=\"/quick14\")    @ResponseBody    public void save14(VO vo) throws IOException &#123;        System.out.println(vo);    &#125;\n\n16-SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装\n1234567891011121314&lt;script src=\"$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.js\"&gt;&lt;/script&gt;    &lt;script&gt;        var userList = new Array();        userList.push(&#123;username:\"zhangsan\",age:18&#125;);        userList.push(&#123;username:\"lisi\",age:28&#125;);        $.ajax(&#123;            type:\"POST\",            url:\"$&#123;pageContext.request.contextPath&#125;/user/quick15\",            data:JSON.stringify(userList),            contentType:\"application/json;charset=utf-8\"        &#125;);    &lt;/script&gt;\n\n12345@RequestMapping(value=\"/quick15\")    @ResponseBody    public void save15(@RequestBody List&lt;User&gt; userList) throws IOException &#123;        System.out.println(userList);    &#125;\n\n17-SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源：\n•在spring-mvc.xml配置文件中指定放行的资源\n​     &lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt;\n•使用&lt;mvc:default-servlet-handler/&gt;标签\n12345&lt;!--开发资源的访问--&gt;    &lt;!--&lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"/&gt;    &lt;mvc:resources mapping=\"/img/**\" location=\"/img/\"/&gt;--&gt;    &lt;mvc:default-servlet-handler/&gt;\n\n18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。\n12345678910111213&lt;!--配置全局过滤的filter--&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;\n\n19-SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定\n1234&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/quick16\" method=\"post\"&gt;    &lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt;    &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt;&lt;/form&gt;\n\n12345@RequestMapping(value=\"/quick16\")    @ResponseBody    public void save16(@RequestParam(value=\"name\",required = false,defaultValue = \"itcast\") String username) throws IOException &#123;        System.out.println(username);    &#125;\n\n20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。\nRestful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：\nGET：用于获取资源\nPOST：用于新建资源\nPUT：用于更新资源\nDELETE：用于删除资源  \n例如：\n/user/1    GET ：       得到 id = 1 的 user\n/user/1   DELETE：  删除 id = 1 的 user\n/user/1    PUT：       更新 id = 1 的 user\n/user       POST：      新增 user\n上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。\nhttp://localhost:8080/itheima_springmvc1/quick17/zhangsan\n12345@RequestMapping(value=\"/quick17/&#123;name&#125;\")@ResponseBody public void save17(@PathVariable(value=\"name\") String username) throws IOException &#123;        System.out.println(username); &#125;\n\n21-SpringMVC的请求-获得请求参数-自定义类型转换器(应用)SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。\n但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。\n12345678910111213public class DateConverter implements Converter&lt;String, Date&gt; &#123;    public Date convert(String dateStr) &#123;        //将日期字符串转换成日期对象 返回        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");        Date date = null;        try &#123;            date = format.parse(dateStr);        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return date;    &#125;&#125;\n\n12345@RequestMapping(value=\"/quick18\")    @ResponseBody    public void save18(Date date) throws IOException &#123;        System.out.println(date);    &#125;\n\n22-SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下：\nHttpServletRequest\nHttpServletResponse\nHttpSession\n1234567@RequestMapping(value=\"/quick19\")    @ResponseBody    public void save19(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException &#123;        System.out.println(request);        System.out.println(response);        System.out.println(session);    &#125;\n\n23-SpringMVC的请求-获得请求参数-获得请求头信息(应用)使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)\n@RequestHeader注解的属性如下：\nvalue：请求头的名称\nrequired：是否必须携带此请求头\n12345@RequestMapping(value=\"/quick20\")    @ResponseBody    public void save20(@RequestHeader(value = \"User-Agent\",required = false) String user_agent) throws IOException &#123;        System.out.println(user_agent);    &#125;\n\n使用@CookieValue可以获得指定Cookie的值\n@CookieValue注解的属性如下：\nvalue：指定cookie的名称\nrequired：是否必须携带此cookie\n12345@RequestMapping(value=\"/quick21\")   @ResponseBody   public void save21(@CookieValue(value = \"JSESSIONID\") String jsessionId) throws IOException &#123;       System.out.println(jsessionId);   &#125;\n\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【SpringMVC】请求-响应/"},{"title":"【SpringMVC】入门&组件解析","date":"2019-09-03T03:48:06.000Z","updated":"2019-09-03T03:54:56.356Z","content":"1. Spring与Web环境集成1.1 ApplicationContext应用上下文获取方式应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。\n在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。\n1.2 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。\n所以我们需要做的只有两件事：\n①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标）\n②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext\n1.3 导入Spring集成web的坐标12345&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n1.4 配置ContextLoaderListener监听器1234567891011&lt;!--全局参数--&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--Spring的监听器--&gt;&lt;listener&gt;\t&lt;listener-class&gt;       org.springframework.web.context.ContextLoaderListener   &lt;/listener-class&gt; &lt;/listener&gt;\n\n1.5 通过工具获得应用上下文对象123ApplicationContext applicationContext =        WebApplicationContextUtils.getWebApplicationContext(servletContext);    Object obj = applicationContext.getBean(\"id\");\n\n知识要点\nSpring集成web环境步骤\n​      ①配置ContextLoaderListener监听器\n​      ②使用WebApplicationContextUtils获得应用上下文\n2. SpringMVC的简介2.1 SpringMVC概述SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。\nSpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。\n2.3 SpringMVC快速入门需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。\n开发步骤\n①导入SpringMVC相关坐标\n②配置SpringMVC核心控制器DispathcerServlet\n③创建Controller类和视图页面\n④使用注解配置Controller类中业务方法的映射地址\n⑤配置SpringMVC核心文件 spring-mvc.xml\n⑥客户端发起请求测试\n代码实现\n①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标\n123456789101112131415161718192021222324 &lt;!--Spring坐标--&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-context&lt;/artifactId&gt;     &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringMVC坐标--&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;     &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--Servlet坐标--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--Jsp坐标--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;    &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt;\n\n②在web.xml配置SpringMVC的核心控制器\n12345678910111213&lt;servlet&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;\t&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n③创建Controller和业务方法\n123456public class QuickController &#123;\tpublic String quickMethod()&#123;\t\tSystem.out.println(\"quickMethod running.....\");\t\treturn \"index\";\t&#125;&#125;\n\n③创建视图页面index.jsp\n12345&lt;html&gt;&lt;body&gt;    &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;\n\n④配置注解\n12345678@Controllerpublic class QuickController &#123;\t@RequestMapping(\"/quick\")\tpublic String quickMethod()&#123;\t\tSystem.out.println(\"quickMethod running.....\");\t\t\treturn \"index\";\t&#125;&#125;\n\n⑤创建spring-mvc.xml\n12345678910111213&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"      xmlns:mvc=\"http://www.springframework.org/schema/mvc\"    xmlns:context=\"http://www.springframework.org/schema/context\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd     http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd      http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;!--配置注解扫描--&gt;    &lt;context:component-scan base-package=\"com.itheima\"/&gt;&lt;/beans&gt;\n\n⑥访问测试地址\n1http://localhost:8080/itheima_springmvc1/quick\n\n控制台打印\n\n页面显示\n\n2.3 SpringMVC流程图示\n\n2.4 知识要点SpringMVC的开发步骤 \n   ①导入SpringMVC相关坐标\n   ②配置SpringMVC核心控制器DispathcerServlet\n   ③创建Controller类和视图页面\n   ④使用注解配置Controller类中业务方法的映射地址\n   ⑤配置SpringMVC核心文件 spring-mvc.xml\n   ⑥客户端发起请求测试\n3. SpringMVC的组件解析3.1 SpringMVC的执行流程\n①用户发送请求至前端控制器DispatcherServlet。\n②DispatcherServlet收到请求调用HandlerMapping处理器映射器。\n③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。\n④DispatcherServlet调用HandlerAdapter处理器适配器。\n⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。\n⑥Controller执行完成返回ModelAndView。\n⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。\n⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。\n⑨ViewReslover解析后返回具体View。\n⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。\n3.2 SpringMVC组件解析\n前端控制器：DispatcherServlet\n\n​    用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由\n它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。\n\n处理器映射器：HandlerMapping\n\n​    HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的\n映射方式，例如：配置文件方式，实现接口方式，注解方式等。\n\n处理器适配器：HandlerAdapter\n\n​    通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理\n器进行执行。\n\n处理器：Handler\n\n​    它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由\nHandler 对具体的用户请求进行处理。\n\n视图解析器：View Resolver\n\n​    View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。\n\n视图：View\n\n​    SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面\n3.3 SpringMVC注解解析@RequestMapping\n作用：用于建立请求 URL 和处理请求方法之间的对应关系\n位置：\n​      类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录\n​      方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径\n属性：\n​      value：用于指定请求的URL。它和path属性的作用是一样的\n​      method：用于指定请求的方式\n​      params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样\n例如：\n​      params = {“accountName”}，表示请求参数必须有accountName\n​      params = {“moeny!100”}，表示请求参数中money不能是100\n1.mvc命名空间引入\n123456命名空间：xmlns:context=\"http://www.springframework.org/schema/context\"        xmlns:mvc=\"http://www.springframework.org/schema/mvc\"约束地址：http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc         http://www.springframework.org/schema/mvc/spring-mvc.xsd\n\n2.组件扫描\nSpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package=“com.itheima.controller”/&gt;进行组件扫描。\n3.4 SpringMVC的XML配置解析SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：\n1org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver\n\n翻看该解析器源码，可以看到该解析器的默认设置，如下：\n1234REDIRECT_URL_PREFIX = &quot;redirect:&quot;  --重定向前缀FORWARD_URL_PREFIX = &quot;forward:&quot;    --转发前缀（默认值）prefix = &quot;&quot;;     --视图名称前缀suffix = &quot;&quot;;     --视图名称后缀\n\n\n视图解析器\n\n我们可以通过属性注入的方式修改视图的的前后缀\n12345&lt;!--配置内部资源视图解析器--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;  &lt;property name=\"prefix\" value=\"/WEB-INF/views/\"&gt;&lt;/property&gt;  &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt;\n\n3.5 知识要点SpringMVC的相关组件 \n前端控制器：DispatcherServlet\n处理器映射器：HandlerMapping\n处理器适配器：HandlerAdapter\n处理器：Handler\n视图解析器：View Resolver\n视图：View\nSpringMVC的注解和配置 \n请求映射注解：@RequestMapping\n视图解析器配置：\nREDIRECT_URL_PREFIX = “redirect:”  \nFORWARD_URL_PREFIX = “forward:”    \nprefix = “”;     \nsuffix = “”;     \n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【SpringMVC】入门-组件解析/"},{"title":"【Spring】AOP","date":"2019-08-31T14:21:23.000Z","updated":"2019-08-31T14:22:12.232Z","content":"1.Spring 的 AOP 简介1.1 什么是 AOPAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。\nAOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n1.2 AOP 的作用及其优势作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强\n优势：减少重复代码，提高开发效率，并且便于维护\n1.3 AOP 的底层实现实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。\n1.4 AOP 的动态代理技术常用的动态代理技术\nJDK 代理 : 基于接口的动态代理技术\ncglib 代理：基于父类的动态代理技术\n\n1.5 JDK 的动态代理①目标类接口\n123public interface TargetInterface &#123;    public void method();&#125;\n\n②目标类\n123456public class Target implements TargetInterface &#123;    @Override    public void method() &#123;        System.out.println(\"Target running....\");    &#125;&#125;\n\n③动态代理代码\n1234567891011121314Target target = new Target(); //创建目标对象//创建代理对象TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args)             throws Throwable &#123;                System.out.println(\"前置增强代码...\");                Object invoke = method.invoke(target, args);                System.out.println(\"后置增强代码...\");                return invoke;            &#125;        &#125;);\n\n④  调用代理对象的方法测试\n12// 测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method();\n\n\n1.6 cglib 的动态代理①目标类\n12345public class Target &#123;    public void method() &#123;        System.out.println(\"Target running....\");    &#125;&#125;\n\n②动态代理代码\n1234567891011121314Target target = new Target(); //创建目标对象Enhancer enhancer = new Enhancer();   //创建增强器enhancer.setSuperclass(Target.class); //设置父类enhancer.setCallback(new MethodInterceptor() &#123; //设置回调    @Override    public Object intercept(Object o, Method method, Object[] objects,     MethodProxy methodProxy) throws Throwable &#123;        System.out.println(\"前置代码增强....\");        Object invoke = method.invoke(target, objects);        System.out.println(\"后置代码增强....\");        return invoke;    &#125;&#125;);Target proxy = (Target) enhancer.create(); //创建代理对象\n\n③调用代理对象的方法测试\n12//测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method();\n\n\n1.7 AOP 相关概念Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。\n在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：\n\nTarget（目标对象）：代理的目标对象\nProxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类\nJoinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点\nPointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义\nAdvice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知\nAspect（切面）：是切入点和通知（引介）的结合\nWeaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入\n\n1.8 AOP 开发明确的事项\n1.8 AOP 开发明确的事项\n1.8 AOP 开发明确的事项1)需要编写的内容\n编写核心业务代码（目标类的目标方法）\n编写切面类，切面类中有通知(增强功能方法)\n在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合\n\n2）AOP 技术实现的内容Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。\n3）AOP 底层使用哪种代理方式在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。\n1.9 知识要点\naop：面向切面编程\n\naop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理\n\naop的重点概念：\n  1234567Pointcut（切入点）：被增强的方法Advice（通知/ 增强）：封装增强业务逻辑的方法Aspect（切面）：切点+通知Weaving（织入）：将切点与通知结合的过程\n\n开发明确事项：\n  12345谁是切点（切点表达式配置）谁是通知（切面类中的增强方法）将切点和通知进行织入配置\n\n\n\n2. 基于 XML 的 AOP 开发2.1 快速入门①导入 AOP 相关坐标\n②创建目标接口和目标类（内部有切点）\n③创建切面类（内部有增强方法）\n④将目标类和切面类的对象创建权交给 spring\n⑤在 applicationContext.xml 中配置织入关系\n⑥测试代码\n①导入 AOP 相关坐标\n123456789101112&lt;!--导入spring的context坐标，context依赖aop--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- aspectj的织入 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;  &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt;\n\n②创建目标接口和目标类（内部有切点）\n12345678910public interface TargetInterface &#123;    public void method();&#125;public class Target implements TargetInterface &#123;    @Override    public void method() &#123;        System.out.println(\"Target running....\");    &#125;&#125;\n\n③创建切面类（内部有增强方法）\n123456public class MyAspect &#123;    //前置增强方法    public void before()&#123;        System.out.println(\"前置代码增强.....\");    &#125;&#125;\n\n④将目标类和切面类的对象创建权交给 spring\n1234&lt;!--配置目标类--&gt;&lt;bean id=\"target\" class=\"com.itheima.aop.Target\"&gt;&lt;/bean&gt;&lt;!--配置切面类--&gt;&lt;bean id=\"myAspect\" class=\"com.itheima.aop.MyAspect\"&gt;&lt;/bean&gt;\n\n⑤在 applicationContext.xml 中配置织入关系\n导入aop命名空间\n1234567891011&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n⑤在 applicationContext.xml 中配置织入关系\n配置切点表达式和前置增强的织入关系\n1234567&lt;aop:config&gt;    &lt;!--引用myAspect的Bean为切面对象--&gt;    &lt;aop:aspect ref=\"myAspect\"&gt;        &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt;        &lt;aop:before method=\"before\" pointcut=\"execution(public void com.itheima.aop.Target.method())\"&gt;&lt;/aop:before&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n⑥测试代码\n12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class AopTest &#123;    @Autowired    private TargetInterface target;    @Test    public void test1()&#123;        target.method();    &#125;&#125;\n\n⑦测试结果\n\n2.2 XML 配置 AOP 详解1) 切点表达式的写法表达式语法：\n1execution([修饰符] 返回值类型 包名.类名.方法名(参数))\n\n\n访问修饰符可以省略\n返回值类型、包名、类名、方法名可以使用星号*  代表任意\n包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类\n参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表\n\n例如：\n12345execution(public void com.itheima.aop.Target.method())\texecution(void com.itheima.aop.Target.*(..))execution(* com.itheima.aop.*.*(..))execution(* com.itheima.aop..*.*(..))execution(* *..*.*(..))\n\n2) 通知的类型通知的配置语法：\n1&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式\"&gt;&lt;/aop:通知类型&gt;\n\n\n3) 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。\n1234567&lt;aop:config&gt;    &lt;!--引用myAspect的Bean为切面对象--&gt;    &lt;aop:aspect ref=\"myAspect\"&gt;        &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.itheima.aop.*.*(..))\"/&gt;        &lt;aop:before method=\"before\" pointcut-ref=\"myPointcut\"&gt;&lt;/aop:before&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n2.3 知识要点\naop织入的配置\n\n12345&lt;aop:config&gt;    &lt;aop:aspect ref=“切面类”&gt;        &lt;aop:before method=“通知方法名称” pointcut=“切点表达式\"&gt;&lt;/aop:before&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n\n通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知\n切点表达式的写法：\n\n1execution([修饰符] 返回值类型 包名.类名.方法名(参数))\n\n3.基于注解的 AOP 开发3.1 快速入门基于注解的aop开发步骤：\n①创建目标接口和目标类（内部有切点）\n②创建切面类（内部有增强方法）\n③将目标类和切面类的对象创建权交给 spring\n④在切面类中使用注解配置织入关系\n⑤在配置文件中开启组件扫描和 AOP 的自动代理\n⑥测试\n①创建目标接口和目标类（内部有切点）\n12345678910public interface TargetInterface &#123;    public void method();&#125;public class Target implements TargetInterface &#123;    @Override    public void method() &#123;        System.out.println(\"Target running....\");    &#125;&#125;\n\n②创建切面类（内部有增强方法)\n123456public class MyAspect &#123;    //前置增强方法    public void before()&#123;        System.out.println(\"前置代码增强.....\");    &#125;&#125;\n\n③将目标类和切面类的对象创建权交给 spring\n12345678910111213@Component(\"target\")public class Target implements TargetInterface &#123;    @Override    public void method() &#123;        System.out.println(\"Target running....\");    &#125;&#125;@Component(\"myAspect\")public class MyAspect &#123;    public void before()&#123;        System.out.println(\"前置代码增强.....\");    &#125;&#125;\n\n④在切面类中使用注解配置织入关系\n12345678@Component(\"myAspect\")@Aspectpublic class MyAspect &#123;    @Before(\"execution(* com.itheima.aop.*.*(..))\")    public void before()&#123;        System.out.println(\"前置代码增强.....\");    &#125;&#125;\n\n⑤在配置文件中开启组件扫描和 AOP 的自动代理\n12345&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=\"com.itheima.aop\"/&gt;&lt;!--aop的自动代理--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;\n\n⑥测试代码\n12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class AopTest &#123;    @Autowired    private TargetInterface target;    @Test    public void test1()&#123;        target.method();    &#125;&#125;\n\n⑦测试结果\n\n3.2 注解配置 AOP 详解1) 注解通知的类型通知的配置语法：@通知注解(“切点表达式”)\n\n2) 切点表达式的抽取同 xml配置aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下：\n12345678910@@Component(\"myAspect\")@Aspectpublic class MyAspect &#123;    @Before(\"MyAspect.myPoint()\")    public void before()&#123;        System.out.println(\"前置代码增强.....\");    &#125;    @Pointcut(\"execution(* com.itheima.aop.*.*(..))\")    public void myPoint()&#123;&#125;&#125;\n\n3.3 知识要点\n注解aop开发步骤\n\n①使用@Aspect标注切面类\n②使用@通知注解标注通知方法\n③在配置文件中配置aop自动代理aop:aspectj-autoproxy/\n\n通知注解类型\n\n\n​    \n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【Spring】AOP/"},{"title":"【Spring】IoC&DI","date":"2019-08-31T14:16:46.000Z","updated":"2019-09-03T03:51:02.058Z","content":"1. spring概述1.1 Spring是什么（理解）Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。\n提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架\n1.2 Spring的优势（理解）方便解耦，简化开发\nAOP 编程的支持\n声明式事务的支持\n方便程序的测试\n1.3 Spring的体系结构（了解）\n2. spring快速入门2.1 Spring程序开发步骤\n①导入 Spring 开发的基本包坐标\n②编写 Dao 接口和实现类\n③创建 Spring 核心配置文件\n④在 Spring 配置文件中配置 UserDaoImpl\n⑤使用 Spring 的 API 获得 Bean 实例\n2.2 导入Spring开发的基本包坐标1234567891011&lt;properties&gt;\t&lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt;&lt;dependencies&gt;     &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-context&lt;/artifactId&gt;         &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2.3 编写Dao接口和实现类12345678910public interface UserDao &#123;      public void save();&#125;public class UserDaoImpl implements UserDao &#123;          @Override          public void save() &#123;        \tSystem.out.println(\"UserDao save method running....\");\t&#125;&#125;\n\n2.4 创建Spring核心配置文件在类路径下（resources）创建applicationContext.xml配置文件\n12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"             \t\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"    http://www.springframework.org/schema/beans      \t             http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt;\n\n2.5 在Spring配置文件中配置UserDaoImpl123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"             \t\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"    http://www.springframework.org/schema/beans      \t             http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;   &lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n2.6 使用Spring的API获得Bean实例123456@Testpublic void test1()&#123;\t\tApplicationContext applicationContext = new               ClassPathXmlApplicationContext(\"applicationContext.xml\");             UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\");   \t\t\t\t userDao.save(); &#125;\n\n3. Spring配置文件3.1 Bean标签基本配置用于配置对象交由Spring 来创建。\n默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。\n基本属性：\nid：Bean实例在Spring容器中的唯一标识\nclass：Bean的全限定名称\n3.2 Bean标签范围配置scope:指对象的作用范围，取值如下： \n\n\n\n取值范围\n说明\n\n\n\nsingleton\n默认值，单例的\n\n\nprototype\n多例的\n\n\nrequest\nWEB   项目中，Spring   创建一个   Bean   的对象，将对象存入到   request   域中\n\n\nsession\nWEB   项目中，Spring   创建一个   Bean   的对象，将对象存入到   session   域中\n\n\nglobal   session\nWEB   项目中，应用在   Portlet   环境，如果没有   Portlet   环境那么globalSession   相当于   session\n\n\n1）当scope的取值为singleton时\n​      Bean的实例化个数：1个\n​      Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例\n​      Bean的生命周期：\n对象创建：当应用加载，创建容器时，对象就被创建了\n对象运行：只要容器在，对象一直活着\n对象销毁：当应用卸载，销毁容器时，对象就被销毁了\n2）当scope的取值为prototype时\n​      Bean的实例化个数：多个\n​      Bean的实例化时机：当调用getBean()方法时实例化Bean\n对象创建：当使用对象时，创建新的对象实例\n对象运行：只要对象在使用中，就一直活着\n对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了\n3.3 Bean生命周期配置init-method：指定类中的初始化方法名称\ndestroy-method：指定类中销毁方法名称\n3.4 Bean实例化三种方式1） 使用无参构造方法实例化（常用）\n​      它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败\n1&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"/&gt;\n\n2） 工厂静态方法实例化\n​      工厂的静态方法返回Bean实例\n12345public class StaticFactoryBean &#123;    public static UserDao createUserDao()&#123;        return new UserDaoImpl();    &#125;&#125;\n\n12&lt;bean id=\"userDao\" class=\"com.itheima.factory.StaticFactoryBean\"       factory-method=\"createUserDao\" /&gt;\n\n3） 工厂实例方法实例化\n​      工厂的非静态方法返回Bean实例\n12345public class DynamicFactoryBean &#123;  \tpublic UserDao createUserDao()&#123;        \t\treturn new UserDaoImpl(); \t&#125;&#125;\n\n12&lt;bean id=\"factoryBean\" class=\"com.itheima.factory.DynamicFactoryBean\"/&gt;&lt;bean id=\"userDao\" factory-bean=\"factoryBean\" factory-method=\"createUserDao\"/&gt;\n\n应用场景：JDBC获得Connation需要先创建DriverMananger对象\n3.5 Bean的依赖注入入门①创建 UserService，UserService 内部在调用 UserDao的save() 方法\n12345678public class UserServiceImpl implements UserService &#123;\t@Override\tpublic void save() &#123;         ApplicationContext applicationContext = new                  ClassPathXmlApplicationContext(\"applicationContext.xml\");       \t           UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\");\t          userDao.save(); \t&#125; &#125;\n\n②将 UserServiceImpl 的创建权交给 Spring\n1&lt;bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\"/&gt;\n\n③从 Spring 容器中获得 UserService 进行操作\n123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");UserService userService = (UserService) applicationContext.getBean(\"userService\");userService.save();\n\n3.6 Bean的依赖注入概念依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。\n在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。\nIOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。\n那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。\n简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取\n3.7 Bean的依赖注入方式①构造方法\n​      创建有参构造\n12345678public class UserServiceImpl implements UserService &#123;@Overridepublic void save() &#123;ApplicationContext applicationContext = new                  ClassPathXmlApplicationContext(\"applicationContext.xml\");       UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\");              userDao.save();    &#125; &#125;\n\n​      配置Spring容器调用有参构造时进行注入\n123&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"/&gt;&lt;bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\"&gt;      \t\t   \t&lt;constructor-arg name=\"userDao\" ref=\"userDao\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n\n②set方法\n​      在UserServiceImpl中添加setUserDao方法\n12345678910public class UserServiceImpl implements UserService &#123;    private UserDao userDao;    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;          &#125;     @Override        public void save() &#123;         \t\t userDao.save();\t&#125;&#125;\n\n​      配置Spring容器调用set方法进行注入\n1234&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"/&gt;&lt;bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\"&gt;\t&lt;property name=\"userDao\" ref=\"userDao\"/&gt;&lt;/bean&gt;\n\nset方法:P命名空间注入\n​      P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下：\n​      首先，需要引入P命名空间：\n1xmlns:p=\"http://www.springframework.org/schema/p\"\n\n其次，需要修改注入方式\n12&lt;bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\" p:userDao- ref=\"userDao\"/&gt;\n\n3.8 Bean的依赖注入的数据类型上面的操作，都是注入的引用Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。\n注入数据的三种数据类型 \n普通数据类型\n引用数据类型\n集合数据类型\n其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。\nBean的依赖注入的数据类型\n（1）普通数据类型的注入\n1234567891011121314public class UserDaoImpl implements UserDao &#123;private String company;    private int age;    public void setCompany(String company) &#123;        this.company = company;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void save() &#123;        System.out.println(company+\"===\"+age);        System.out.println(\"UserDao save method running....\");       &#125;&#125;\n\n1234&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt;    &lt;property name=\"company\" value=\"传智播客\"&gt;&lt;/property&gt;    &lt;property name=\"age\" value=\"15\"&gt;&lt;/property&gt;&lt;/bean&gt;\n\n（2）集合数据类型（List）的注入\n12345678910public class UserDaoImpl implements UserDao &#123;\tprivate List&lt;String&gt; strList;\tpublic void setStrList(List&lt;String&gt; strList) &#123;\t\tthis.strList = strList;\t&#125;\tpublic void save() &#123;        System.out.println(strList);        System.out.println(\"UserDao save method running....\");\t&#125;&#125;\n\n123456789&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt;    &lt;property name=\"strList\"&gt;        &lt;list&gt;            &lt;value&gt;aaa&lt;/value&gt;            &lt;value&gt;bbb&lt;/value&gt;            &lt;value&gt;ccc&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n（3）集合数据类型（List）的注入\n12345678910public class UserDaoImpl implements UserDao &#123;\tprivate List&lt;User&gt; userList;\tpublic void setUserList(List&lt;User&gt; userList) &#123;\tthis.userList = userList;   &#125;public void save() &#123;\tSystem.out.println(userList);\tSystem.out.println(\"UserDao save method running....\");\t&#125;&#125;\n\n123456789101112&lt;bean id=\"u1\" class=\"com.itheima.domain.User\"/&gt;&lt;bean id=\"u2\" class=\"com.itheima.domain.User\"/&gt;&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt;    &lt;property name=\"userList\"&gt;        &lt;list&gt;            &lt;bean class=\"com.itheima.domain.User\"/&gt;            &lt;bean class=\"com.itheima.domain.User\"/&gt;            &lt;ref bean=\"u1\"/&gt;            &lt;ref bean=\"u2\"/&gt;               &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n（4）集合数据类型（ Map&lt;String,User&gt; ）的注入\n12345678910public class UserDaoImpl implements UserDao &#123;    private Map&lt;String,User&gt; userMap;    public void setUserMap(Map&lt;String, User&gt; userMap) &#123;    this.userMap = userMap;    &#125;    public void save() &#123;      \tSystem.out.println(userMap);\tSystem.out.println(\"UserDao save method running....\");\t&#125;&#125;\n\n12345678910&lt;bean id=\"u1\" class=\"com.itheima.domain.User\"/&gt;&lt;bean id=\"u2\" class=\"com.itheima.domain.User\"/&gt;&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt;    &lt;property name=\"userMap\"&gt;        &lt;map&gt;                        &lt;entry key=\"user1\" value-ref=\"u1\"/&gt;            &lt;entry key=\"user2\" value-ref=\"u2\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n（5）集合数据类型（Properties）的注入\n12345678910public class UserDaoImpl implements UserDao &#123;    private Properties properties;    public void setProperties(Properties properties) &#123;        this.properties = properties;    &#125;\tpublic void save() &#123;\t\tSystem.out.println(properties);\t\tSystem.out.println(\"UserDao save method running....\");\t&#125;&#125;\n\n123456789&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt;    &lt;property name=\"properties\"&gt;        &lt;props&gt;            &lt;prop key=\"p1\"&gt;aaa&lt;/prop&gt;            &lt;prop key=\"p2\"&gt;bbb&lt;/prop&gt;             &lt;prop key=\"p3\"&gt;ccc&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n3.9 引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载\n1&lt;import resource=\"applicationContext-xxx.xml\"/&gt;\n\n4. spring相关API4.1 ApplicationContext的继承体系\nBeanFactory是最上层接口。\napplicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象\nApplicationContext实现了BeanFactory接口,所以功能会强大一些,平常我们用ApplicationContext\n4.2 ApplicationContext的实现类1）ClassPathXmlApplicationContext \n​      它是从类的根路径下加载配置文件 推荐使用这种\n2）FileSystemXmlApplicationContext \n​      它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。\n3）AnnotationConfigApplicationContext\n​      当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。\n4.3 getBean()方法使用1234567public Object getBean(String name) throws BeansException &#123;  \tassertBeanFactoryActive();   \treturn getBeanFactory().getBean(name);&#125;public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException &#123;   \t\t\t    \tassertBeanFactoryActive();\treturn getBeanFactory().getBean(requiredType);&#125;\n\n其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。\n当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错\ngetBean()方法使用\n1234ApplicationContext applicationContext = new             ClassPathXmlApplicationContext(\"applicationContext.xml\");  UserService userService1 = (UserService) applicationContext.getBean(\"userService\");  UserService userService2 = applicationContext.getBean(UserService.class);\n\n5.Spring配置数据源5.1 数据源（连接池）的作用数据源(连接池)是提高程序性能如出现的\n事先实例化数据源，初始化部分连接资源\n使用连接资源时从数据源中获取\n使用完毕后将连接资源归还给数据源\n常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等\n开发步骤\n①导入数据源的坐标和数据库驱动坐标\n②创建数据源对象\n③设置数据源的基本连接数据\n④使用数据源获取连接资源和归还连接资源\n5.2 数据源的手动创建①导入c3p0和druid的坐标\n123456789101112&lt;!-- C3P0连接池 --&gt;&lt;dependency&gt;    &lt;groupId&gt;c3p0&lt;/groupId&gt;    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;    &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Druid连接池 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;\n\n①导入mysql数据库驱动坐标\n123456&lt;!-- mysql驱动 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.39&lt;/version&gt;&lt;/dependency&gt;\n\n②创建C3P0连接池\n123456789101112@Testpublic void testC3P0() throws Exception &#123;\t//创建数据源\tComboPooledDataSource dataSource = new ComboPooledDataSource();\t//设置数据库连接参数    dataSource.setDriverClass(\"com.mysql.jdbc.Driver\");    \t               \t               dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\");    dataSource.setUser(\"root\");    dataSource.setPassword(\"root\");\t//获得连接对象\tConnection connection = dataSource.getConnection();\tSystem.out.println(connection);&#125;\n\n②创建Druid连接池\n12345678910111213@Testpublic void testDruid() throws Exception &#123;    //创建数据源    DruidDataSource dataSource = new DruidDataSource();    //设置数据库连接参数    dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");     dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\");       dataSource.setUsername(\"root\");    dataSource.setPassword(\"root\");    //获得连接对象    Connection connection = dataSource.getConnection();        System.out.println(connection);&#125;\n\n③提取jdbc.properties配置文件\n1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root\n\n④读取jdbc.properties配置文件创建连接池\n123456789101112@Testpublic void testC3P0ByProperties() throws Exception &#123;    //加载类路径下的jdbc.properties    ResourceBundle rb = ResourceBundle.getBundle(\"jdbc\");    ComboPooledDataSource dataSource = new ComboPooledDataSource();     dataSource.setDriverClass(rb.getString(\"jdbc.driver\"));       dataSource.setJdbcUrl(rb.getString(\"jdbc.url\"));     dataSource.setUser(rb.getString(\"jdbc.username\"));     dataSource.setPassword(rb.getString(\"jdbc.password\"));    Connection connection = dataSource.getConnection();       System.out.println(connection);&#125;\n\n5.3 Spring配置数据源可以将DataSource的创建权交由Spring容器去完成\nDataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的\nDataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入\n123456&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt;    &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt;    &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/test\"/&gt;    &lt;property name=\"user\" value=\"root\"/&gt;    &lt;property name=\"password\" value=\"root\"/&gt;&lt;/bean&gt;\n\n测试从容器当中获取数据源\n123456ApplicationContext applicationContext = new            ClassPathXmlApplicationContext(\"applicationContext.xml\");               DataSource dataSource = (DataSource) applicationContext.getBean(\"dataSource\");Connection connection = dataSource.getConnection();System.out.println(connection);\n\n5.4 抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。\n首先，需要引入context命名空间和约束路径：\n命名空间：xmlns:context=”http://www.springframework.org/schema/context&quot;\n约束路径：http://www.springframework.org/schema/context​                       \n​                   http://www.springframework.org/schema/context/spring-context.xsd\n1234567&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt;    &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt;    &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt;    &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt;    &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/bean&gt;\n\n5.5 知识要点Spring容器加载properties文件\n12&lt;context:property-placeholder location=\"xx.properties\"/&gt;&lt;property name=\"\" value=\"$&#123;key&#125;\"/&gt;\n\n6. Spring注解开发6.1 Spring原始注解Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 \nSpring原始注解主要是替代的配置\n\n\n\n注解\n说明\n\n\n\n@Component\n使用在类上用于实例化Bean\n\n\n@Controller\n使用在web层类上用于实例化Bean\n\n\n@Service\n使用在service层类上用于实例化Bean\n\n\n@Repository\n使用在dao层类上用于实例化Bean\n\n\n@Autowired\n使用在字段上用于根据类型依赖注入\n\n\n@Qualifier\n结合@Autowired一起使用用于根据名称进行依赖注入\n\n\n@Resource\n相当于@Autowired+@Qualifier，按照名称进行注入\n\n\n@Value\n注入普通属性\n\n\n@Scope\n标注Bean的作用范围\n\n\n@PostConstruct\n使用在方法上标注该方法是Bean的初始化方法\n\n\n@PreDestroy\n使用在方法上标注该方法是Bean的销毁方法\n\n\n注意：\n使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。\n12&lt;!--注解的组件扫描--&gt;&lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt;\n\n使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。\n12345678//@Component(\"userDao\")@Repository(\"userDao\")public class UserDaoImpl implements UserDao &#123;    @Override    public void save() &#123;    \tSystem.out.println(\"save running... ...\");    &#125;&#125;\n\n使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化\n使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入\n123456789101112//@Component(\"userService\")@Service(\"userService\")public class UserServiceImpl implements UserService &#123;    /*@Autowired    @Qualifier(\"userDao\")*/    @Resource(name=\"userDao\")    private UserDao userDao;    @Override    public void save() &#123;          \t  userDao.save();    &#125;&#125;\n\n使用@Value进行字符串的注入\n12345678910111213@Repository(\"userDao\")public class UserDaoImpl implements UserDao &#123;    @Value(\"注入普通数据\")    private String str;    @Value(\"$&#123;jdbc.driver&#125;\")    private String driver;    @Override    public void save() &#123;        System.out.println(str);        System.out.println(driver);        System.out.println(\"save running... ...\");    &#125;&#125;\n\n使用@Scope标注Bean的范围\n12345//@Scope(\"prototype\")@Scope(\"singleton\")public class UserDaoImpl implements UserDao &#123;   //此处省略代码&#125;\n\n使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法\n12345678@PostConstructpublic void init()&#123;\tSystem.out.println(\"初始化方法....\");&#125;@PreDestroypublic void destroy()&#123;\tSystem.out.println(\"销毁方法.....\");&#125;\n\n6.2 Spring新注解使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下：\n非自定义的Bean的配置：\n加载properties文件的配置：context:property-placeholder\n组件扫描的配置：context:component-scan\n引入其他文件：\n\n\n\n注解\n说明\n\n\n\n@Configuration\n用于指定当前类是一个 Spring   配置类，当创建容器时会从该类上加载注解\n\n\n@ComponentScan\n用于指定 Spring   在初始化容器时要扫描的包。   作用和在 Spring   的 xml 配置文件中的   &lt;context:component-scan   base-package=”com.itheima”/&gt;一样\n\n\n@Bean\n使用在方法上，标注将该方法的返回值存储到   Spring   容器中\n\n\n@PropertySource\n用于加载.properties   文件中的配置\n\n\n@Import\n用于导入其他配置类\n\n\n@Configuration\n@ComponentScan\n@Import\n12345@Configuration@ComponentScan(\"com.itheima\")@Import(&#123;DataSourceConfiguration.class&#125;)public class SpringConfiguration &#123;&#125;\n\n@PropertySource\n@value\n12345678910@PropertySource(\"classpath:jdbc.properties\")public class DataSourceConfiguration &#123;    @Value(\"$&#123;jdbc.driver&#125;\")    private String driver;    @Value(\"$&#123;jdbc.url&#125;\")    private String url;    @Value(\"$&#123;jdbc.username&#125;\")    private String username;    @Value(\"$&#123;jdbc.password&#125;\")    private String password;\n\n@Bean\n123456789@Bean(name=\"dataSource\")public DataSource getDataSource() throws PropertyVetoException &#123;     ComboPooledDataSource dataSource = new ComboPooledDataSource();     dataSource.setDriverClass(driver);    dataSource.setJdbcUrl(url);    dataSource.setUser(username);    dataSource.setPassword(password);    return dataSource;&#125;\n\n测试加载核心配置类创建Spring容器\n1234567891011@Testpublic void testAnnoConfiguration() throws Exception &#123;ApplicationContext applicationContext = new           AnnotationConfigApplicationContext(SpringConfiguration.class);    UserService userService = (UserService)        applicationContext.getBean(\"userService\");    userService.save();    DataSource dataSource = (DataSource)     applicationContext.getBean(\"dataSource\");    Connection connection = dataSource.getConnection();     System.out.println(connection);    &#125;\n\n7. Spring整合Junit7.1 原始Junit测试Spring的问题在测试类中，每个测试方法都有以下两行代码：\n12ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");IAccountService as = ac.getBean(\"accountService\",IAccountService.class);\n\n这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。\n7.2 上述问题解决思路让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它\n将需要进行测试Bean直接在测试类中进行注入\n7.3 Spring集成Junit步骤①导入spring集成Junit的坐标\n②使用@Runwith注解替换原来的运行期\n③使用@ContextConfiguration指定配置文件或配置类\n④使用@Autowired注入需要测试的对象\n⑤创建测试方法进行测试\n7.4 Spring集成Junit代码实现①导入spring集成Junit的坐标\n123456789101112&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\n\n②使用@Runwith注解替换原来的运行期\n123@RunWith(SpringJUnit4ClassRunner.class)public class SpringJunitTest &#123;&#125;\n\n③使用@ContextConfiguration指定配置文件或配置类\n1234567@RunWith(SpringJUnit4ClassRunner.class)//加载spring核心配置文件//@ContextConfiguration(value = &#123;\"classpath:applicationContext.xml\"&#125;)//加载spring核心配置类@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123;&#125;\n\n④使用@Autowired注入需要测试的对象\n123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123;    @Autowired    private UserService userService;&#125;\n\n⑤创建测试方法进行测试\n123456789@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)\u000bpublic class SpringJunitTest &#123;    @Autowired    private UserService userService;    @Test    public void testUserService()&#123;   \t userService.save();    &#125;&#125;\n\nSpring集成Junit步骤\n①导入spring集成Junit的坐标\n②使用@Runwith注解替换原来的运行期\n③使用@ContextConfiguration指定配置文件或配置类\n④使用@Autowired注入需要测试的对象\n⑤创建测试方法进行测试\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【Spring】IoC-DI/"},{"title":"【刨根问底】HashMap","date":"2019-08-26T17:04:51.000Z","updated":"2019-08-26T17:07:54.493Z","content":"\n首先复习一下二进制位运算，下面会用到\n\nhashmap简述：\n底层数据结构：数组+红黑树+链表（）\n默认初始容量16；给定容量初始值的话，容量为大于或等于给定值的最小2^n^（如给定初始值是1000或1024，那么容量是1024）\n最大容量2^31^。(源码是1&lt;&lt;30)，\n负载因子默认0.75,\n极限值12，就是说当容量超过12（16*0.75）时，hashmap扩容，\n扩容后容量是原来的2倍\n链表长度&gt;=8转换为红黑树，长度&lt;=6退化成链表\nHashMap三种遍历方式\n\n123456789101112131415161718192021222324252627public class HashMapExam &#123;    public static void main(String[] args) &#123;        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(16);        for (int i = 0; i &lt; 15; i++) &#123;            map.put(i, new String(new char[]&#123;(char) ('A'+ i)&#125;));        &#125;        System.out.println(\"======keySet=======\");        Set&lt;Integer&gt; set = map.keySet();        Iterator&lt;Integer&gt; iterator = set.iterator();        while (iterator.hasNext()) &#123;            System.out.println(iterator.next());        &#125;        System.out.println(\"======values=======\");        Collection&lt;String&gt; values = map.values();        Iterator&lt;String&gt; stringIterator=values.iterator();        while (stringIterator.hasNext()) &#123;            System.out.println(stringIterator.next());        &#125;        System.out.println(\"======entrySet=======\");        for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;            System.out.println(entry);        &#125;    &#125;&#125;\n\n原理图：\nHashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！\n为什么用数组+链表？数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到.链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。\n\n这里的hash值并不是指hashcode，而是将hashcode高低十六位异或过的。后面会解释\n\n其它解决hash冲突的方法？\n开放定址法/再散列法\n再哈希法\n\n\n细节内容可以跳转解决哈希冲突的方法\n\n用LinkedList代替数组结构可以么?是可以的。\n既然是可以的,为什么HashMap不用LinkedList,而选用数组?因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。\n那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList?因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高，而ArrayList的扩容机制是1.5倍扩容\n为什么HashMap长度是2的次幂?为了存取高效，减少碰撞，使元素尽量分布均匀\n\n实现分布均匀\n\nhash：hashmap中元素在table中的index是由key的hash值决定的（并不是直接使用key的hash值，至于为什么下面会说到），hash值是int数据类型，范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的，所以这个散列值是不能直接拿来用的\n取模(%)：设定一个数组长度，然后用hash对数组长度取模。hash%length\n\n\n均匀分布且高效\n\n二进制位操作：位移运算比取模这类运算快，所以优化成hash&amp;(length-1)\n  也就是说hash%length等价于hash&amp;(length-1)。\n  与运算是怎么保证数据均匀分布的？\n  二进制中2的n次方实际就是1后面n个0，2的n次方-1，实际就是n个1\n  \n  如果容积是2的n次方，那么length-1的二进制就是n个1 ，那么hash&amp;(length-1)也就是hash和1111……1111111进行与运算，最开始有复习二进制位运算，与运算可以取一个数中指定位\n  \n  这样hash&amp;(length-1)就保证了数据原来的分布状态，只要hash是分布均匀的，那么数据就是分布均匀的\n\n\n\n\n如何保证创建的hashmap容量是2的幂次方？123456789101112/** *给定了容量初始值创建hashmap时，此方法保证创建的返回给定目标容量的2次幂 */ static final int tableSizeFor(int cap) &#123;        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    &#125;\n\n如上面源码中tableSizeFor（int cap)方法。进行位运算。假如我指定容量是1024，忽略int n = cap - 1,那么操作如下\n\n结果是：给定值是1024，返回值是n+1=2048。我期望是:：给定值是2^n^时，hashmap容量等于给定值，现在的结果不符合期望。\n所以在或运算之前先将给定值-1，避免给定值恰巧是2^n^时，hashmap容量等于给定值*2\n为什么为什么要先高16位异或低16位再取模运算?1234567/***计算key的hash值*/static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;\n\n若hash值只用自身的hashcode,那么后面计算元素在数组中位置的时候，只有hash的低位与（length-1）做&amp;操作.这样会带来哈希冲突的风险。增加这个异或操作（扰动函数）之后，hash的高位参与进来，降低了hash冲突的几率\nhashmap中put元素的过程?对key的hashCode()做hash运算，计算index;如果没碰撞直接放到bucket里；如果碰撞了，以链表的形式存在buckets后；如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树(JDK1.8中的改动)；如果节点已经存在就替换old value(保证key的唯一性)如果bucket满了(超过load factor*current capacity)，就要resize。\nhashmap中get元素的过程?对key的hashCode()做hash运算，计算index;如果在bucket里的第一个节点里直接命中，则直接返回；如果有冲突，则通过key.equals(k)去查找对应的Entry;\n\n若为树，则在树中通过key.equals(k)查找，O(logn)；\n若为链表，则在链表中通过key.equals(k)查找，O(n)。\n\n你还知道哪些hash算法？先说一下hash算法干嘛的，Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。比较出名的有MurmurHash、MD4、MD5等等\n参考-感谢hashmap源码解析\nhashmap面试专题\n数组的最大长度\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【刨根问底】HashMap/"},{"title":"【java集合框架】(2)对比总结","date":"2019-08-26T16:58:41.000Z","updated":"2019-08-26T17:02:28.750Z","content":"集合比较：底层数据结构，是否线程安全，元素是否有序，能否重复，能否为null，扩容机制\n\n\n[TOC]\nJava容器可分为两大类：\n\nCollection\nList\nArrayList\nLinkedList\nVector(了解，已过时)\n\n\nSet\nHashSet\nLinkedHashSet\n\n\nTreeSet\n\n\n\n\nMap\nHashMap\nLinkedHashMap\n\n\nTreeMap\nConcurrentHashMap\nHashtable(了解，，已过时)\n\n\n\n着重标出的那些就是我们用得最多的容器。\nList,Set,Map三者的区别？\nList(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象\nSet(注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。\nMap(用Key来搜索的专家): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。\n\nList和Map的区别共同点：\n\n都是Java常用的容器，都是接口(ps：写出来感觉好像和没写一样…..)\n\n不同点：\n\n存储结构不同：\nList是存储单列的集合\nMap存储的是key-value键值对的集合\n\n\n元素是否可重复：\nList允许元素重复\nMap不允许key重复\n\n\n是否有序：\nList集合是有序的(存储有序)\nMap集合是无序的(存储无序)\n\n\n\nArrayList和Vector的区别？共同点：\n\n这两个类都实现了List接口，它们都是有序的集合(存储有序)，底层是数组。我们可以按位置索引号取出某个元素，允许元素重复和为null。\n\n区别：\n\n同步性：\nArrayList是非同步的\nVector是同步的\n即便需要同步的时候，我们可以使用Collections工具类来构建出同步的ArrayList而不用Vector\n\n\n扩容大小：\nVector增长原来的一倍，ArrayList增长原来的0.5倍\n\n\n\n为什么Vector过时了Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。\nArraylist不是同步的，所以在不需要保证线程安全时建议使用Arraylist。\nArraylist 与 LinkedList 区别\n1. 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；\n2. 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\n3. 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。\n4. 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。\n5. 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。\n\nHashMap和Hashtable的区别共同点：\n\n从存储结构和实现来讲基本上都是相同的，都是实现Map接口~\n\n区别：\n\n底层数据结构：\nJDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\nHashtable 没有这样的机制。\n\n\n同步性：\nHashMap：是非同步的（线程不安全\nHashtable：是同步的（线程安全\n需要同步的时候，我们往往不使用，而使用ConcurrentHashMapConcurrentHashMap基于JDK1.8源码剖析 \n\n\n是否允许为null：\nHashMap：允许一个null 键（key）,多个null值（value）。\nHashtable：不允许为null键（会抛出 NullPointerException）\n\n\n扩容机制\nHashMap： ①创建时如果不指定容量初始值，默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，HashMap 会将其扩充为2的幂次方大小\nHashtable：①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1；创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小\n\n\ncontains方法\nHashtable有contains方法\nHashMap把Hashtable的contains方法去掉了，改成了containsValue和containsKey\n\n\n\nHashMap 和 HashSet区别Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()?我们知道Set集合实际大都使用的是Map集合的put方法来添加元素。\n以HashSet为例，HashSet里的元素不能重复，在源码(HashMap)是这样体现的：\n123456789101112// 1. 如果key 相等  if (p.hash == hash &amp;&amp;    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))    e = p;// 2. 修改对应的value   if (e != null) &#123; // existing mapping for key        V oldValue = e.value;        if (!onlyIfAbsent || oldValue == null)            e.value = value;        afterNodeAccess(e);        return oldValue;   &#125;\n\n添加元素的时候，如果key(也对应的Set集合的元素)相等，那么则修改value值。而在Set集合中，value值仅仅是一个Object对象罢了(该对象对Set本身而言是无用的)。\n也就是说：Set集合如果添加的元素相同时，是根本没有插入的(仅修改了一个无用的value值)！从源码(HashMap)中也看出来，==和equals()方法都有使用！\nCollection和Collections的区别\nCollection是集合的上级接口，继承它的有Set和List接口\nCollections是集合的工具类，提供了一系列的静态方法对集合的搜索、查找、同步等操作\n\n说出ArrayList,LinkedList的存储性能和特性ArrayList的底层是数组，LinkedList的底层是双向链表。\n\nArrayList它支持以角标位置进行索引出对应的元素(随机访问)，而LinkedList则需要遍历整个链表来获取对应的元素。因此一般来说ArrayList的访问速度是要比LinkedList要快的 \nArrayList由于是数组，对于删除和修改而言消耗是比较大(复制和移动数组实现)，LinkedList是双向链表删除和修改只需要修改对应的指针即可，消耗是很小的。因此一般来说LinkedList的增删速度是要比ArrayList要快的 \n\n扩展：ArrayList的增删未必就是比LinkedList要慢。\n\n如果增删都是在末尾来操作【每次调用的都是remove()和add()】，此时ArrayList就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，速度是会比LinkedList要快的。(我测试过)\n如果删除操作的位置是在中间。由于LinkedList的消耗主要是在遍历上，ArrayList的消耗主要是在移动和复制上(底层调用的是arraycopy()方法，是native方法)。\nLinkedList的遍历速度是要慢于ArrayList的复制移动速度的\n如果数据量有百万级的时，还是ArrayList要快。(我测试过)\n\n\n\nEnumeration和Iterator接口的区别这个我在前面的文章中也没有详细去讲它们，只是大概知道的是：Iterator替代了Enumeration，Enumeration是一个旧的迭代器了。\n与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。\n\n我们在做练习的时候，迭代时会不会经常出错，抛出ConcurrentModificationException异常，说我们在遍历的时候还在修改元素。\n这其实就是fail-fast机制~具体可参考博文：https://blog.csdn.net/panweiwei1994/article/details/77051261 \n\n区别有三点：\n\nIterator的方法名比Enumeration更科学\nIterator有fail-fast机制，比Enumeration更安全\nIterator能够删除元素，Enumeration并不能删除元素\n\nListIterator有什么特点\nListIterator继承了Iterator接口，它用于遍历List集合的元素。\nListIterator可以实现双向遍历,添加元素，设置元素 \n\n并发集合类是什么？Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。\n\n迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。\n一部分类为：\nCopyOnWriteArrayList\nConcurrentHashMap\nCopyOnWriteArraySet\n\n\n\nJava中HashMap的key值要是为类对象则该类需要满足什么条件？需要同时重写该类的hashCode()方法和它的equals()方法。\n\n从源码可以得知，在插入元素的时候是先算出该对象的hashCode。如果hashcode相等话的。那么表明该对象是存储在同一个位置上的。\n如果调用equals()方法，两个key相同，则替换元素 \n如果调用equals()方法，两个key不相同，则说明该hashCode仅仅是碰巧相同，此时是散列冲突，将新增的元素放在桶子上\n\n一般来说，我们会认为：只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的！因为，Object底层比较的是两个对象的地址，而对我们开发来说这样的意义并不大~这也就为什么我们要重写equals()方法\n重写了equals()方法，就要重写hashCode()的方法。因为equals()认定了这两个对象相同，而同一个对象调用hashCode()方法时，是应该返回相同的值的！\n与Java集合框架相关的有哪些最好的实践\n根据需要确定集合的类型。如果是单列的集合，我们考虑用Collection下的子接口ArrayList和Set。如果是映射，我们就考虑使用Map~\n确定完我们的集合类型，我们接下来确定使用该集合类型下的哪个子类~我认为可以简单分成几个步骤：\n是否需要同步\n去找线程安全的集合类使用\n\n\n迭代时是否需要有序(插入顺序有序)\n去找Linked双向列表结构的\n\n\n是否需要排序(自然顺序或者手动排序)\n去找Tree红黑树类型的(JDK1.8)\n\n\n\n\n估算存放集合的数据量有多大，无论是List还是Map，它们实现动态增长，都是有性能消耗的。在初始集合的时候给出一个合理的容量会减少动态增长时的消耗~\n使用泛型，避免在运行时出现ClassCastException\n尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性\n\nArrayList集合加入1万条数据，应该怎么提高效率ArrayList的默认初始容量为10，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了10万条数据了，我们可以直接在初始化的时候就设置ArrayList的容量！\n这样就可以提高效率了~\n关于集合存储null值|–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。\n|–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.\nArrayList扩容机制以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。\nArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）。 JDk1.6版本时，扩容之后容量为 1.5 倍+1\n源码：\n1int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)\n\n向 ArrayList 添加大量元素之前最好先使用ensureCapacity 方法，以减少增量重新分配的次数\n\n参考链接：通过源码一步一步分析ArrayList 扩容机制\n\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【java集合框架】-2-对比总结/"},{"title":"【java集合框架】(1)基础","date":"2019-08-19T17:02:37.000Z","updated":"2019-08-26T17:02:55.226Z","content":"Java中的集合框架定义了一套规范，用来表示、操作集合，使具体操作与实现细节解耦。\n其实可以把一个集合看成一个微型数据库，操作不外乎“增删改查”四种操作，我们在学习使用一个具体的集合类时，需要把这四个操作的空间复杂度弄清楚。\n\n\n\n声明：笔记基于JDK1.8\n\n集合概述集合是java中提供的一种容器，可以用来存储多个数据。java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。\n集合和数组既然都是容器，它们有啥区别呢？\n\n长度区别  ​    数组的长度固定  ​    集合的长度可变\n内容不同　　　　数组存储的是同一种类型的元素　　　　集合可以存储不同类型的元素\n存储元素的数据类型不同　　　　数组可以存储基本数据类型，也可以存储引用数据类型（引用数据类型存储的是地址值）。　　　　集合只能存储引用数据类型（也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象）。\n\n集合与数组的转换\n数组转换成list集合：Arrays.asList(arr)\nlist集合转换成数组: list.toArray()\n\nJava集合类库构成了集合类的框架，包含了大量的接口，抽象类，框架图如下所示：从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等\n集合框架体系\n集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：\n\n接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象\n实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。\n算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现\n\n迭代器接口：IteratorIterator接口主要用来遍历集合对象中的元素\n原理\n常用方法：\nE next()：返回将要访问的下一个对象\nboolean hasNext()：如果存在可访问的元素，返回true\nvoid remove()：删除上次访问的对象，必须紧跟在访问一个元素之后执行\n\n遍历元素通过反复调用next方法，可以逐个访问集合中的每个元素，如果到达了集合的末尾，next方法将抛出一个NoSuchElementException，因此在调用next方法之前需要调用hasNext方法判断是否到达集合末尾。使用方法如下：\n1234567Collection&lt;String&gt; c = ...Iterator&lt;String&gt; iter = c.iterator();while(iter.hasNext())&#123;    String ele = iter.next();    ...&#125;\n\n从Java JDK1.5之后，可以用for循环来执行上述循环操作了，更加简洁，代码如下：\n1234for(String ele : c)&#123;    ...&#125;\n\n删除元素Iterator接口的remove方法删除上次调用next方法返回的元素，与遍历元素类似，删除某元素前，需要判断该元素是否有意义。正确的使用方法如下：\n1234Collection&lt;String&gt; c = ...Iterator&lt;String&gt; iter = c.iterator();iter.next();iter.remove();\n\n可以看到先调用next方法返回想要删除的元素，再删除之。如果上次访问之后，集合已经发生变化，再调用remove方法，将抛出一个IllegalStateException。以下的使用方法都是错误的：\n\n没有调用next方法\n  12Iterator&lt;String&gt; iter = c.iterator();iter.remove();\n\n调用一次next方法，删除连续两个元素\n  1234Iterator&lt;String&gt; iter = c.iterator();iter.next();iter.remove();iter.remove();\n\n\n\n\n它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。\n\nCollectionCollection是所有单列集合的父接口，Collection 接口存储一组无序，可重复的5对象。\n在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法(部分)如下：\n常用方法\n\n\n返回值\n方法和描述\n\n\n\nboolean\nadd(E e)`把给定的对象添加到当前集合中 。\n\n\nvoid\nclear()清空集合中所有的元素。\n\n\nboolean\nremove(E e)把给定的对象在当前集合中删除。\n\n\nboolean\ncontains(E e)判断当前集合中是否包含给定的对象。\n\n\nboolean\nisEmpty()判断当前集合是否为空。\n\n\nint\nsize()返回集合中元素的个数。\n\n\nObject[]\ntoArray()把集合中的元素，存储到数组中。\n\n\nList集合有序(指存储和取出元素的顺序一致)、存储元素可重复\nList集合特有方法因为list集合是有序的，所以它的特有方法都和元素的索引有关\n\n\n\n返回值\n方法和描述\n\n\n\nvoid\nadd(int index, E element)  将指定的元素插入此列表中的指定位置（可选操作）。\n\n\nboolean\naddAll(int index,  Collection&lt;? extends E&gt; c)  将指定集合中的所有元素插入到此列表中的指定位置（可选操作）。\n\n\nE\nget(int index)  返回此列表中指定位置的元素。\n\n\nint\nindexOf(Object o)  返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。\n\n\nint\nlastIndexOf(Object o)  返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。\n\n\nListIterator&lt;E&gt;\nlistIterator()   返回列表中的列表迭代器（按适当的顺序）。\n\n\nListIterator&lt;E&gt;\nlistIterator(int index)   从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n\n\nE\nremove(int index)   删除该列表中指定位置的元素（可选操作）。\n\n\nE\nset(int index, E element)  用指定的元素（可选操作）替换此列表中指定位置的元素。\n\n\nList&lt;E&gt;\nsubList(int fromIndex,  int toIndex)  返回此列表中指定的 fromIndex （含）和 toIndex之间的视图。\n\n\nList集合的子类List集合有ArrayList、Vector和LinkedList三个常用子类。\nList集合的子类对比:ArrayList的底层数据结构是数组，查询快，增删慢，线程不安全，效率高\nVector的底层数据结构是数组，查询快，增删慢，线程安全，效率低\nLinkedList的底层数据结构是链表，查询慢，增删快。线程不安全，效率高\nVector的特有方法：\n\n添加功能\npublic void addElement(Object obj)\n\n\n获取功能\npublic Object elementAt(int index)\npublic Enumeration elements()\n\n\n\nLinkedList的特有方法：\n\n添加功能\npublic void addFirst(Object obj)\npublic void addLast(Object obj)\n\n\n获取功能\npublic Object getFirst()\npublic Object getLast()\n\n\n删除功能\npublic Object removeFirst()\npublic Object removeLast()\n\n\n\npublic E removeLast() :移除并返回此列表的后一个元素。public E pop() :从此列表所表示的堆栈处弹出一个元素。public void push(E e) :将元素推入此列表所表示的堆栈。 \nSet集合Set集合与Collection集合基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同，无序(指元素的存储和取出顺序不一致)、存储元素不可重复\nSet集合的子类Set集合有HashSet和TreeSet两个常用子类。HashSet类有一个子类LinkedHashSet\nSet集合子类对比HashSet的底层数据结构是哈希表，存储无序，线程不安全，元素值可以是null\n\nHashSet是基于HashMap实现的\n\nTreeSet的底层数据结构是红黑树(是一种自平衡的二叉树)，存储有序，线程不安全，性能较差\n\nTreeSet是基于TreeMap实现的\n\nLinkedHashSet的底层数据结构由链表和哈希表组成，存储元素的特点是有序、唯一\n\n由链表保证元素有序，由哈希表保证元素唯一。\n\nHashSet\nHashSet结构\n\n\n\nHashSet如何保证元素唯一性的原理：\n  \n\n因为在java源码中，equals()是在Hash值相同的时候才能调用到equals()，所以一定要重写HashCode()，否则Hash值都不一样也永远不可能进入到equals()中去。\n\n\n\nTreeSetTreeSet类底层数据结构是红黑树(是一种自平衡的二叉树)。\n\nTreeSet类如何保证元素唯一性呢?  ​    根据比较的返回值是否是0来决定\n\nTreeSet类如何保证元素的排序呢?\n  a：自然排序(元素具备比较性)  ​    让元素所属的类实现Comparable接口\n  b：比较器排序(集合具备比较性)  ​    让集合接收一个Comparator的实现类对象\n\n\n\n参考：TreeSet集合如何保持集合中的元素有序\n\nLinkedHashSetLinkedHashMap 较之 HashMap 内部多维护了一个双向链表用来维护元素的添加顺序。\nMap集合Collection中的集合称为单列集合，Map中的集合称为双列集合。\nMap中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。\n需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。\n\n常用方法\n\n\n返回值\n方法和描述\n\n\n\nV\nput(K key, V value)把指定的键与指定的值添加到Map集合中。\n\n\nV\nremove(Object key)把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。\n\n\nV\nget(Object key) 根据指定的键，在Map集合中获取对应的值。\n\n\nboolean\ncontainsKey(Object key) 判断集合中是否包含指定的键。\n\n\nSet\nkeySet()获取Map集合中所有的键，存储到Set集合中。\n\n\nSet&lt;Map.Entry&lt;K,V&gt;&gt;\nentrySet() 获取到Map集合中所有的键值对对象的集合(Set集合)\n\n\n\ntips:使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； \n若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。\n\n有关于 map.entrySet() 和 keySet():1、如果遍历 hashMap() 时 entrySet() 方法是将 key 和 value 全部取出来,所以性能开销是可以预计的, 而  keySet() 方法进行遍历的时候是根据取出的 key 值去查询对应的 value 值, 所以如果 key 值是比较简单的结构(如  1,2,3…)的话性能消耗上是比 entrySet() 方法低, 但随着 key 值得复杂度提高 entrySet() 的优势就会显露出来。\n2、综合比较在只遍历 key 的时候使用 keySet(), 在只遍历 value 的是使用 values() 方法, 在遍历 key-value 的时候使用 entrySet() 是比较合理的选择。\n3、如果遍历 TreeMap 的时候, 不同于 HashMap 在遍历 ThreeMap 的 key-value 时候务必使用  entrySet() 它要远远高于其他两个的性能, 同样只遍历 key 的时候使用 keySet(), 在只遍历 value 的是使用  values() 方法对于 TreeMap 也同样适用。\n\ntips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。\n\nHashMap当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。\nLinkedHashMapHashMap下面的一个子类。它是链表和哈希表组合的一个数据存储结构。保证了数据的有序\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【java集合框架】(1).基础/"},{"title":"【消息中间件】(1).ActiveMQ","date":"2019-08-08T02:35:14.000Z","updated":"2019-08-14T09:24:23.082Z","content":"什么是消息中间件？\n就像快递代收点或者蜂巢。介于快递公司（操作系统）和收件人（应用程序）之间的产品。解决了送件人必须当面亲手将快递交给收件人的问题\n\n\n消息中间件的组成\nBroker\n\n消息服务器，作为server提供消息核心服务\n\nProducer\n\n消息生产者，业务的发起方，负责生产消息传输给broker，\n\nConsumer\n\n消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理\n\nTopic\n\n主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的       广播\n\nQueue\n\n队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收\n\nMessage\n\n消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输\nJMSJava消息服务（Java Message Service，JMS）：是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。       JMS本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。它类似JDBC(java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。\n体系结构\n消息中间件模式分类\n点对点\n  PTP点对点:使用queue作为通信载体\n  \n\n\n说明：消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。\n\n发布订阅\n  Pub/Sub发布订阅（广播）：使用topic作为通信载体 \n  \n\n\n说明：消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。\nqueue实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到一个消息的拷贝。\n5种消息体格式JMS API定义了5种消息体格式，可以使用不同形式发送接收数据，并可兼容现有的消息格式：比如\n\nTextMessage：String对象\nMapMessage：名/值对的集合，名为String对象，值类型可以是Java任何数据类型\nBytesMessage：字节流\nStreamMessage：java中的输入输出流\nObjectMessage：Java中的可序列化对象\nMessage：没有消息体，只有消息头和属性\n\n为什么用核心的有 3 个：解耦、异步、削峰。\n1. 解耦看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……\n\n在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！\n如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。\n\n总结：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。\n2. 异步再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。\n\n一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。\n如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！\n\n3.削峰每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。\n一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。\n但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。\n\n如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。\n\n这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。\n有什么缺点1. 系统可用性降低系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。\n2. 系统复杂性提高硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已\n3. 一致性问题A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。\n所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，用，还是得用的。。。\n目前流行的消息队列优缺点对比\n\n\n特性\nActiveMQ\nRabbitMQ\nRocketMQ\nKafka\n\n\n\n单机吞吐量\n万级，吞吐量比RocketMQ和Kafka要低了一个数量级\n万级，吞吐量比RocketMQ和Kafka要低了一个数量级\n10万级，RocketMQ也是可以支撑高吞吐的一种MQ\n10万级别，这是kafka最大的优点，就是吞吐量高。 一般配合大数据类的系统来进行实时数据计算、日志采集等场景\n\n\ntopic数量对吞吐量的影响\n\n\ntopic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降,这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic\ntopic从几十个到几百个的时候，吞吐量会大幅度下降 所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源\n\n\n时效性\nms级\n微秒级，这是rabbitmq的一大特点，延迟是最低的\nms级\n延迟在ms级以内\n\n\n可用性\n高，基于主从架构实现高可用性\n高，基于主从架构实现高可用性\n非常高，分布式架构\n非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用\n\n\n消息可靠性\n有较低的概率丢失数据\n\n经过参数优化配置，可以做到0丢失\n经过参数优化配置，消息可以做到0丢失\n\n\n功能支持\nMQ领域的功能极其完备\n基于erlang开发，所以并发能力很强，性能极其好，延时很低\nMQ功能较为完善，还是分布式的，扩展性好\n功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准\n\n\n优劣势总结：\n\nActiveMQ：非常成熟，功能强大，在业内大量的公司以及项目中都有应用 偶尔会有较低概率丢失消息 而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本 而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用\n\nRabbitMQ：erlang语言开发，性能极其好，延时很低； 吞吐量到万级，MQ功能比较完备 而且开源提供的管理界面非常棒，用起来很好用 社区相对比较活跃，几乎每个月都发布几个版本分 在国内一些互联网公司近几年用rabbitmq也比较多一些 但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。 而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。 而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。\n\n接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障 日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景 而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码 还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的\n\nkafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展 同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量 而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略 这个特性天然适合大数据实时计算以及日志收集\n\n\n怎么用更新中…\n参考-感谢消息中间件面试题\nMQ详解及四大MQ比较\nMQ学习笔记\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【消息中间件】-1-ActiveMQ/"},{"title":"【科学上网】Vultr+Shadowsocks","date":"2019-08-01T07:06:02.000Z","updated":"2019-08-14T09:24:09.861Z","content":"之前一直使用国内付费VPN，从没动手操作过服务器。在国内VPN接连被墙后有想过使用国外的付费VPN，但是国内的环境让我有点犹豫会不会突然哪天有GG了，所以一直没有使用。转机出现是在自学JAVA的过程中了解到了VPS，这让我决定折腾一下。下面就是整个搭建过程。\n\n\n购买VPS服务器这一步比较像你办了张储值卡（注册账户并充值），然后用储值卡里的钱买了一台电脑。只不过这台电脑“看得见摸不到”\n第一次接触这件事，购买之前查查评测和推荐很有必要！至少能扫扫盲，躲避明显的大坑。下面是一些评测和推荐\n\n\n适合搭建SSR的国外VPS服务器推荐\n2019最好的国外VPS推荐\n2019优质VPS服务商推荐\n\n\n如果不想看或者看完之后还是纠结不知道选哪个！那根据我的使用，推荐使用Vultr。\n理由也比较简单：试错成本低。Vultr可以随时部署随时摧毁服务器，是按每小时计费的，一个月是5美金，大概0.007美金一小时，就算你创建一个服务器IP刚好是被某墙屏蔽了，那就删掉也只是扣0.1美金。\n1、注册并登录Vultr注册：https://my.vultr.com/\n注册登录后，使用支付宝给账户充值，支付宝要最低10美金，相当于人民币70块钱左右。\n\n2、部署服务器\n在个人页面点击Products然后再点右面的➕号按钮添加一个服务器\n\n\n\n在打开的页面选择新加坡（Singapore）服务器 (实际使用网速良好) ，如果喜欢其他服务器也可以选择，后续操作是一样一样的\n\n\n\n接下来要注意了，系统最好选择CentOS 6，方便之后在网上搜索教程和一键脚本的适配，点击CentOS可以下拉选择6。\n\n\n\n选择套餐，当然ss不需要配置太高的服务器，最低配置5美金一个月的就可以。\n\n\n\n接着就是部署起来了，当然你也可以给服务器起个名字再部署\n\n\n\n接着等待服务器启动完成，看到Status是绿色的Running就是启动完成了，这个过程大概需要1-3分钟。\n\n\n\n点击进入，查看服务器信息。后面用到IP地址和密码时可以来这里复制。\n\n\n\n启动完成后，当然测试一下有没有被封掉IP了，打开命令管理器或者终端，输入 ping+你的IP地址，例如我服务器IP是8.8.8.8，则ping 8.8.8.8，如果出现下图的返回信息则这个IP是可以用的，偶尔一个request timeout也是可以的，是掉包现象，如果出现一直request timeout就把这服务器删掉重新部署吧。\n\n图中往返行程时间实际体验是可以的，正常使用不会很慢，如果时间是二三百毫秒同样建议销毁服务器重新部署\n\n在服务器安装ss（Shadowsocks服务器端）Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。\n1、连接服务器\nwindows10,可以打开系统自带的powershell工具，输入ssh root@你的服务器IP地址\n\n\n\n如果连接成功，那跳过”ssh工具安装“这个步骤，如果连接失败则需要另外安装ssh工具\n\n\n安装并运行SecureCRT\n\nwindows下ssh连接需要下载连接工具，根据个人习惯选择，这里以SecureCRT为例，\n\n\n安装好SecureCRT后点击File–Quick Connect\n\n\n配置连接\n\n\n弹出窗口输入服务器密码（可以去服务器详情页复制）\n\n\n上面登录成功后如图所示\n\n\n如果服务器可以ping通，但SecureCRT无法连接说明服务器被封端口了（很多vultr日本服务器有这种状况），请更换其他地区服务器或者更换服务器商\n\n\n\n\n\n2、安装ss服务端\n复制一键安装脚本到SecureCRT执行（感谢@teddysun大佬制作的一键安装脚本）\n\n123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log\n\n\n蹦出一大串代码后，停在这里了。按回车继续\n\n\n\n接着又蹦出些东西，是让我们选择ss的服务器端，这里我选择go版本的，输入3按回车\n\n\n\n接下来是要填入ss客户端登录的密码\n\n\n\n接下来是输入端口号（1-65535任意数字），这里我填默认的\n\n\n\n接下来是选择加密方式，默认就好，按回车\n\n\n\n继续回车\n\n\n\n等待一会，看到下图就是大功告成了（图里的信息在配置ss客户端的时候会用到，可以截图备忘一下）\n\n\n3、安装ss客户端各终端下载地址：\nWindows：https://github.com/shadowsocks/shadowsocks-windows/releases\nMAC:https://github.com/shadowsocks/ShadowsocksX-NG/releases\nAndroid:https://github.com/shadowsocks/shadowsocks-android/releases\nLinux:https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation\niOS：（待更新）\n以Windows为例演示安装使用，打开上面的下载地址\n\n接着解压后打开Shadowsocks.exe，右击右下角小飞机，点击服务器-编辑服务器：\n\n还记得上面建议保存的图片吗？这里就用到了，服务器IP，端口，密码，加密方式，然后点击确定\n\n最后确保打开了PAC模式：\n\n\nPAC模式：就是访问国内网站会走国内IP，访问被封的网站走服务器IP\n全局模式：就是全部走服务器IP\n\n最后在浏览器中输入：www.google.com\n\n大功告成！！！\n参考-感谢给小白的ss翻墙教程\nVultr搭建SS\n浅谈vpn、vps、Proxy以及shadowsocks之间的联系和区别\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/【科学上网】Vultr-Shadowsocks/"},{"title":"如何搜索","date":"2019-07-31T10:35:51.000Z","updated":"2019-07-31T10:53:44.337Z","content":"提高自己的检索效率，更快找到自己想找的信息\n\n\n信息搜索\n搜索逻辑\n\n了解一下其他人的解决方案。比如公司年会，新闻发布会，旅游攻略，美食攻略，社群线下活动。别人已经做过，或者经历过的事情都可以按照这个逻辑\n了解一个问题的全网信息。比如：搜索“历史比价”就会搜到“慢慢买”这个垂直网站。\n了解一下相关手机垂直服务。比如挂号，识花，便签，时间管理，学习等等\n\n\n搜索命令\n\n口语化搜索转化为关键词搜索\n\n示例：如何将iPhone手机中的图片传入电脑。优化成：iphone手机图片 上传电脑\n\n\n限定在特定的网站中。用法：关键词+空格+site:搜索范围所限定的站点。不用加www或者http\n\n限定文件类型。用法：关键词+空格+filetype:文件格式\n\n不包含某关键词。用法：关键词+空格+减号+关键词\n\n特定时间内的关键词信息。用法：关键词+20xx..20xx。限定时间用两个英文句号隔开，不是中文\n\n将关键词限定在标题中。用法：关键字+空格+intitle:需要限定的关键词\n\n将搜索内容不分词搜索。用法：用引号把搜索关键词括起来\n\n模糊搜索。用法：用“星号”替换记不清的内容，再用引号括起来\n以上指令可以组合使用\n\n\n\n\n资源搜索\n搜索心法\n\n遇到资源问题，先百度再淘宝，不行再问知乎\n\n上面的百度，淘宝和知乎是带只。核心技巧是结合之前的信息搜索技巧在搜索引擎上搜索，找不到再去看一些付费渠道，都搞不定最后去找专家咨询\n\n\n\n\n高级信息搜索的8步\n\n分析问题\n\n选择合适的搜索工具\n\n提取关键词\n\n构造检索式\n\n进行检索\n\n筛选检索结果\n\n调整检索策略\n\n反思总结\n\n核心技巧：搜索引擎是机器，不是人。不要问搜索引擎问题，应当思考我如何描述，可以让他更准确的匹配出所需要的资源\n\n\n\n\n\n","thumbnail":null,"plink":"https://gmahsm.github.io/post/如何搜索/"},{"title":"【Hexo博客攻略】(2).Inside主题配置","date":"2019-07-27T23:19:31.000Z","updated":"2019-07-28T11:19:03.806Z","content":"这次安装的主题是 inside，你也可以选择一个自己喜欢的主题，配置过程大同小异\n\n\n下载主题下载地址：https://github.com/ikeq/hexo-theme-inside\n使用主题我下载的是zip压缩包\n\n解压并重命名主题为 inside\n打开主题文件夹，找到_config.yml 文件，该文件为站点配置文件\n打开_config.yml 文件，将主题修改为 inside。theme: inside（这里配置的主题名一定要和主题文件的名称完全一致）\n\n配置主题主题配置文档：https://blog.oniuo.com/theme-inside\n\n官方的配置文档非常详细，按照自己的喜好一步步操作就可以\n\n部署到服务器cd到blog文件夹下，执行如下命令\n1hexo d -g","plink":"https://gmahsm.github.io/post/【Hexo博客攻略】(2).Inside主题配置/"},{"title":"用Typora写Markdown","date":"2019-07-27T05:23:27.000Z","updated":"2019-08-01T05:34:07.848Z","content":"电脑系统windows，内容主要是Markdown语法和软件快捷键，常用整理\nMarkdown ：是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\nTypora：markdown编辑器。官网：https://www.typora.io\n\n\n语法与快捷键汇总生成目录1[toc] + enter\n\n标题123456# 一阶标题  或者快捷键Ctrl+1## 二阶标题 或者快捷键Ctrl+2### 三阶标题    或者快捷键Ctrl+3#### 四阶标题   或者快捷键Ctrl+4##### 五阶标题  或者快捷键Ctrl+5###### 六阶标题 或者快捷键Ctrl+6\n\n下划线1&lt;u&gt;下划线的内容&lt;/u&gt; 或者快捷键Ctrl+U\n\n斜体12*倾斜内容*_倾斜内容_    或按快捷键Ctrl+I\n\n加粗12**加粗内容**__加粗内容__    或按快捷键Ctrl+B\n\n加粗斜体12***加粗内容***___加粗内容___\n\n删除线1~~删除线的内容~~  或按快捷键Alt+Shift+5\n\n==文字高亮==1==我是最重要的==\n\n角标^1^ 角标21x^2^  上角标   H~2~O  下角标    不是Markdown语法\n\n文本居中1&lt;center&gt;这是要居中的文本内容&lt;/center&gt;\n\n引用1&gt;+空格    或按快捷键ctrl + shift + q\n\n分割线12***+回车  ---+回车    个人习惯“减号”\n\n有序列表1数字+英文小数点(.)+空格\n\n无序列表1+ 、- 、* 任意一种+空格    个人习惯“减号”\n\n代码片段1`代码内容`\n\n代码块1​```+回车    或者快捷键Ctrl+Shift+K\n\n超链接12345673种样式[百度][https://www.baidu.com/]    或者快捷键Ctrl+K     使用频率高[CSDN][CSDN网址][CSDN网址]:https://www.csdn.net/&lt;https://github.com/&gt;\n\n图片1![图片名](网络地址)\n\n表格1234|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |    或者快捷键Ctrl+T\n\n注脚12Typora[^1][^1]:A markdown editor\n\n任务列表123-[ ] 抽烟-[x] 喝酒-[ ] 烫头\n\n符号输入123456789101112\\\\   反斜线\\`   反引号\\*   星号\\_   底线\\&#123; \\&#125;  花括号\\[ \\]  方括号\\( \\)  括弧\\#   井字号\\+   加号\\-   减号\\.   英文句点\\!   惊叹号\n\n特殊符号1234567891011121314151617181920&amp;copy;      版权      &amp;reg;       注册商标&amp;trade;     商标&amp;nbsp;      空格&amp;amp;       和号&amp;quot;      引号&amp;apos;      撇号&amp;lt;        小于号&amp;gt;        大于号&amp;ne;        不等号&amp;le;        小于等于&amp;ge;        大于等于&amp;cent;      分&amp;pound;     磅&amp;euro;      欧元&amp;yen;       元&amp;sect;      节&amp;times;     乘号&amp;divide;    除号&amp;plusmn;    正负号\n\n参考-感谢Typora-书写即为美学\nMarkdown 教程\n使用Markdown快速排版一篇文章\n","plink":"https://gmahsm.github.io/post/用Typora写Markdown/"},{"title":"博客图片不显示","date":"2019-07-24T23:25:12.000Z","updated":"2019-07-28T12:57:49.435Z","content":"为什么图片不显示了？\n本地使用Markdown编辑博客时，图片的引用使用的是本地相对地址。因为图片一直存放在本地的某个文件夹，所以将博客部署到github后引用地址找不到图片文件。\n\n\n有两种解决方法：\n\n配置Hexo\n使用图床工具\n\n配置Hexo\n将hexo配置文件_config.yml 中post_asset_folder设置成true。\n\n这是Hexo的资源文件夹功能，默认是关闭的。设置完成后，再次新建文件时，Hexo会自动建立一个与文章同名的文件夹，可以把与该文章相关的所有资源都放到那个文件夹，\n\n\n安装一个图片插件，\n 在hexo的目录下执行下面命令\n\n\n1npm install https://github.com/CodeFalling/hexo-asset-image --save\n\n​        效果如下图：\n\n\n博客插入图片方式\n\n![图片标题](文章同名文件夹/图片名称.jpg)\n使用图床工具\n下载图床工具 PicGo\n\n设置picgo\n\n设置链接格式，方便插入\n\n\n设置图床，第一次使用直接使用默认的sm.ms即可\n\n\n\n\n使用picgo\n\n找到要插入的图片 Ctrl+C （复制图片）\n上传图片到图床 Ctrl+Shift+P （默认快捷键，自定义快捷键方法请查看官方文档）\n在文章中插入图片 Ctrl+V （工具会以上面设置的链接格式输出到文档\n\n 注意：\n\n方法适用于单张图片的上传、使用。\n批量上传图片可以选中多张图片后拖到上传区，但使用图片需要在工具相册中找到图片并复制图片链接再插入到文章    \n\n\n\n\n更详细的配置和使用可以查看官方配置文档\n\n最后说经过使用发现，方法一缺点很明显：大量占用github pages空间。用《使用hexo-github搭建个人博客》和《博客图片不显示》两篇文做设置对比，使用方法一占用github空间 5.5M，而使用方法二仅占用github空间 390K。面对有限的github pages免费空间，方法二优势是碾压的。\n​    \n","plink":"https://gmahsm.github.io/post/博客图片不显示/"},{"title":"【Hexo博客攻略】(1).基于hexo-github环境搭建","date":"2019-07-24T16:04:43.000Z","updated":"2019-07-28T11:19:15.543Z","content":"注册账号地址：https://github.com\n创建GitHub page\ngithub page的域名形式是固定的\n\n测试\n安装git for windows下载地址：https://gitforwindows.org/。或者搜索 “git for win“\n\n默认选项安装即可安装路径根据自己使用习惯设置\n测试在命令行窗口输入 git 命令，如下图所示即为安装成功\n\n安装node.js下载地址：https://nodejs.org/en/。或者百度搜索 “node.js”\n下载左面的稳定版本\n\n默认选项安装即可安装路径根据自己使用习惯设置\n测试在命令行窗口使用”node -v”命令，显示版本号表示安装成功。如下图\n\nhexo本地使用地址：https://hexo.io/zh-cn/。或者百度搜索&quot;hexo&quot;，即可搜索到安装指令。\n\n安装在d盘新建文件夹’blog’(用户自定义)，使用命令行进入blog文件夹\n12345$  npm install hexo-cli -g    安装hexo$  hexo init blog             初始化该文件夹$  cd blog                    进入初始化完成的文件夹$  npm install\t\t\t\t   安装依赖（所需要的组件）$  hexo s             开启服务器（默认端口：4000，如果端口冲突可以使用 hexo s -p xxx自定义端口\n\n按照顺序依次执行上面指令。完成后访问localhost:4000(端口)。访问到页面表示安装成功。\n参照\n\n成功后访问页面\n将Hexo与github page联系起来git bash：在windows系统下使用git命令的模拟终端（windows自带的cmd功能太弱)\n\n进入blog文件夹，右键，Git Base Here，然后执行登录命令\n\n 12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot;\n\n\n在命令行或终端中使用下面的命令设置git自己的名字和电子邮件。这是因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\n\n效果如下：\n\n本地git与github之间需要通过ssh密钥来连接，需先生成一个密钥，命令如下：\n\n1ssh-keygen -t rsa -C &quot;邮箱&quot;\n\n\n 中间会遇到停顿 ，输入“回车”默认即可，（参考链接：ssh代理详解）\n\n\n\n进入文件夹C:\\Users\\Administrator.ssh，会看到得到的两个文件：\n\n\n\nid_rsa是私钥， id_rsa.pub是密钥\n\n\nssh代理\n\n12eval &quot;$(ssh-agent -s)&quot;\t启动ssh代理ssh-agentssh-add ~/.ssh/id_rsa\t将私钥添加到ssh代理\n\n\nssh代理是一个程序，它可以帮助我们管理私钥，ssh- agent即为ssh代理程序那么什么时候需要ssh代理帮助我们管理私钥呢？当遇到如下情况时，我们会需要ssh代理。    1、不用到处部署私钥使用不同的密钥连接到不同的主机时，需要手动指定对应的密钥，ssh代理可以帮助我们选择对应的密钥进行认证，不用手动指定密钥即可进行连接。    2、不用重复输入密码 当私钥设置了密码，我们又需要频繁的使用私钥进行认证时，ssh代理可以帮助我们免去重复的输入密码的操作。\n\n\n登陆github，点击头像下的settings，添加ssh:\n\n\n\n新建new ssh key，将id_rsa.pub(记事本打开即可)文件里的内容复制进去：\n\n\n\n执行以下指令，测试添加ssh是否成功\n\n1ssh -T git@github.com\n\n​    看到红框标注是自己的用户名表示添加成功\n\n\n进入blog文件夹，找到_config.yml配置文件，修改下面两处\n\n\n\n\n yml对缩进和空格要求很严格，每个英文冒号后面必须有一个空格，该缩进的地方必须要有缩进（比如图2的后三行代码）：\n\n\n创建博客\n  直接使用Markdown编辑器编辑文章，然后存入blog文件夹下的source_posts文件夹；\n 然后执行以下命令\n\n\n12npm install hexo-deployer-git --save\t\t安装hexo-deployer-git扩展插件 hexo d -g\t\t生成静态页面并部署到github上\n\n浏览器访问http://用户名.github.io\n参考链接：hexo官方文档\n搭建步骤参考\nssh代理详解\n","plink":"https://gmahsm.github.io/post/【Hexo博客攻略】(1).基于hexo-github环境搭建/"}]