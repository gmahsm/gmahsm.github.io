{"title":"【java集合框架】(2)对比总结","date":"2019-08-26T16:58:41.000Z","thumbnail":null,"link":"post/【java集合框架】-2-对比总结","tags":["集合框架"],"categories":["奇客工具"],"updated":"2019-08-26T17:02:28.750Z","content":"<p>集合比较：底层数据结构，是否线程安全，元素是否有序，能否重复，能否为null，扩容机制</p>\n<a id=\"more\"></a>\n\n<p>[TOC]</p>\n<p>Java容器可分为两大类：</p>\n<ul>\n<li>Collection<ul>\n<li>List<ul>\n<li><strong>ArrayList</strong></li>\n<li>LinkedList</li>\n<li>Vector(了解，已过时)</li>\n</ul>\n</li>\n<li>Set<ul>\n<li><strong>HashSet</strong><ul>\n<li>LinkedHashSet</li>\n</ul>\n</li>\n<li>TreeSet</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Map<ul>\n<li><strong>HashMap</strong><ul>\n<li>LinkedHashMap</li>\n</ul>\n</li>\n<li>TreeMap</li>\n<li>ConcurrentHashMap</li>\n<li>Hashtable(了解，，已过时)</li>\n</ul>\n</li>\n</ul>\n<p>着重标出的那些就是我们<strong>用得最多</strong>的容器。</p>\n<h1 id=\"List-Set-Map三者的区别？\">List,Set,Map三者的区别？<a href=\"post/【java集合框架】-2-对比总结#List-Set-Map三者的区别？\"></a></h1><ul>\n<li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li>\n<li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li>\n<li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li>\n</ul>\n<h1 id=\"List和Map的区别\">List和Map的区别<a href=\"post/【java集合框架】-2-对比总结#List和Map的区别\"></a></h1><p><strong>共同点：</strong></p>\n<ul>\n<li>都是Java常用的容器，都是接口(ps：写出来感觉好像和没写一样…..)</li>\n</ul>\n<p><strong>不同点：</strong></p>\n<ul>\n<li><strong>存储结构不同</strong>：<ul>\n<li>List是存储单列的集合</li>\n<li>Map存储的是key-value键值对的集合</li>\n</ul>\n</li>\n<li><strong>元素是否可重复</strong>：<ul>\n<li>List允许元素重复</li>\n<li>Map不允许key重复</li>\n</ul>\n</li>\n<li><strong>是否有序</strong>：<ul>\n<li>List集合是有序的(存储有序)</li>\n<li>Map集合是无序的(存储无序)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"ArrayList和Vector的区别？\">ArrayList和Vector的区别？<a href=\"post/【java集合框架】-2-对比总结#ArrayList和Vector的区别？\"></a></h1><p><strong>共同点：</strong></p>\n<ul>\n<li>这两个类都实现了List接口，它们都是<strong>有序</strong>的集合(存储有序)，<strong>底层是数组</strong>。我们可以按位置索引号取出某个元素，<strong>允许元素重复和为null</strong>。</li>\n</ul>\n<p><strong>区别：</strong></p>\n<ul>\n<li><strong>同步性：</strong><ul>\n<li>ArrayList是非同步的</li>\n<li>Vector是同步的</li>\n<li>即便需要同步的时候，我们可以使用Collections工具类来构建出同步的ArrayList而不用Vector</li>\n</ul>\n</li>\n<li><strong>扩容大小：</strong><ul>\n<li>Vector增长原来的一倍，ArrayList增长原来的0.5倍</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"为什么Vector过时了\">为什么Vector过时了<a href=\"post/【java集合框架】-2-对比总结#为什么Vector过时了\"></a></h1><p><code>Vector</code>类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>\n<p><code>Arraylist</code>不是同步的，所以在不需要保证线程安全时建议使用Arraylist。</p>\n<h1 id=\"Arraylist-与-LinkedList-区别\">Arraylist 与 LinkedList 区别<a href=\"post/【java集合框架】-2-对比总结#Arraylist-与-LinkedList-区别\"></a></h1><ul>\n<li><strong>1. 是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>\n<li><strong>2. 底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>\n<li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li>\n<li><strong>4. 是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>\n<li><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>\n</ul>\n<h1 id=\"HashMap和Hashtable的区别\">HashMap和Hashtable的区别<a href=\"post/【java集合框架】-2-对比总结#HashMap和Hashtable的区别\"></a></h1><p><strong>共同点：</strong></p>\n<ul>\n<li>从存储结构和实现来讲基本上都是相同的，都是实现Map接口~</li>\n</ul>\n<p><strong>区别：</strong></p>\n<ul>\n<li><strong>底层数据结构：</strong><ul>\n<li>JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li>\n<li>Hashtable 没有这样的机制。</li>\n</ul>\n</li>\n<li><strong>同步性：</strong><ul>\n<li>HashMap：是非同步的（线程不安全</li>\n<li>Hashtable：是同步的（线程安全</li>\n<li>需要同步的时候，我们往往不使用，而使用ConcurrentHashMap<a href=\"https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484161&idx=1&sn=6f52fb1f714f3ffd2f96a5ee4ebab146&chksm=ebd74200dca0cb16288db11f566cb53cafc580e08fe1c570e0200058e78676f527c014ffef41#rd\" target=\"_blank\" rel=\"noopener\">ConcurrentHashMap基于JDK1.8源码剖析</a> </li>\n</ul>\n</li>\n<li><strong>是否允许为null：</strong><ul>\n<li>HashMap：允许一个null 键（key）,多个null值（value）。</li>\n<li>Hashtable：不允许为null键（会抛出 NullPointerException）</li>\n</ul>\n</li>\n<li><strong>扩容机制</strong><ul>\n<li>HashMap： ①创建时如果不指定容量初始值，默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，HashMap 会将其扩充为2的幂次方大小</li>\n<li>Hashtable：①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1；创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小</li>\n</ul>\n</li>\n<li><strong>contains方法</strong><ul>\n<li>Hashtable有contains方法</li>\n<li>HashMap把Hashtable的contains方法去掉了，改成了containsValue和containsKey</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"HashMap-和-HashSet区别\">HashMap 和 HashSet区别<a href=\"post/【java集合框架】-2-对比总结#HashMap-和-HashSet区别\"></a></h1><h1 id=\"Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals\">Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()?<a href=\"post/【java集合框架】-2-对比总结#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals\"></a></h1><p>我们知道Set集合实际<strong>大都使用的是Map集合的put方法来添加元素</strong>。</p>\n<p>以HashSet为例，HashSet里的元素不能重复，在源码(HashMap)是这样体现的：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. 如果key 相等  </span><br><span class=\"line\">if (p.hash == hash &amp;&amp;</span><br><span class=\"line\">    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">    e = p;</span><br><span class=\"line\">// 2. 修改对应的value</span><br><span class=\"line\">   if (e != null) &#123; // existing mapping for key</span><br><span class=\"line\">        V oldValue = e.value;</span><br><span class=\"line\">        if (!onlyIfAbsent || oldValue == null)</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">        afterNodeAccess(e);</span><br><span class=\"line\">        return oldValue;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>添加元素的时候，如果key(也对应的Set集合的元素)相等，那么则修改value值。而在Set集合中，value值仅仅是一个Object对象罢了(<strong>该对象对Set本身而言是无用的</strong>)。</p>\n<p>也就是说：Set集合如果添加的元素相同时，<strong>是根本没有插入的(仅修改了一个无用的value值)</strong>！从源码(HashMap)中也看出来，<strong>==和equals()方法都有使用</strong>！</p>\n<h1 id=\"Collection和Collections的区别\">Collection和Collections的区别<a href=\"post/【java集合框架】-2-对比总结#Collection和Collections的区别\"></a></h1><ol>\n<li>Collection是集合的上级<strong>接口</strong>，继承它的有Set和List接口</li>\n<li>Collections是集合的<strong>工具类</strong>，提供了一系列的静态方法对集合的搜索、查找、同步等操作</li>\n</ol>\n<h1 id=\"说出ArrayList-LinkedList的存储性能和特性\">说出ArrayList,LinkedList的存储性能和特性<a href=\"post/【java集合框架】-2-对比总结#说出ArrayList-LinkedList的存储性能和特性\"></a></h1><p>ArrayList的底层是数组，LinkedList的底层是双向链表。</p>\n<ul>\n<li>ArrayList它支持以角标位置进行索引出对应的元素(随机访问)，而LinkedList则需要遍历整个链表来获取对应的元素。因此<strong>一般来说ArrayList的访问速度是要比LinkedList要快的</strong> </li>\n<li>ArrayList由于是数组，对于删除和修改而言消耗是比较大(复制和移动数组实现)，LinkedList是双向链表删除和修改只需要修改对应的指针即可，消耗是很小的。因此<strong>一般来说LinkedList的增删速度是要比ArrayList要快的</strong> </li>\n</ul>\n<h2 id=\"扩展：\">扩展：<a href=\"post/【java集合框架】-2-对比总结#扩展：\"></a></h2><p>ArrayList的增删<strong>未必</strong>就是比LinkedList要慢。</p>\n<ul>\n<li>如果增删都是在<strong>末尾</strong>来操作【每次调用的都是remove()和add()】，此时ArrayList就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，<strong>速度是会比LinkedList要快的</strong>。(我测试过)</li>\n<li>如果<strong>删除操作</strong>的位置是在<strong>中间</strong>。由于LinkedList的消耗主要是在遍历上，ArrayList的消耗主要是在移动和复制上(底层调用的是arraycopy()方法，是native方法)。<ul>\n<li>LinkedList的遍历速度是要慢于ArrayList的复制移动速度的</li>\n<li>如果数据量有百万级的时，<strong>还是ArrayList要快</strong>。(我测试过)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Enumeration和Iterator接口的区别\">Enumeration和Iterator接口的区别<a href=\"post/【java集合框架】-2-对比总结#Enumeration和Iterator接口的区别\"></a></h1><p>这个我在前面的文章中也没有详细去讲它们，只是大概知道的是：Iterator替代了Enumeration，Enumeration是一个旧的迭代器了。</p>\n<p>与Enumeration相比，Iterator更加安全，<strong>因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合</strong>。</p>\n<ul>\n<li>我们在做练习的时候，迭代时会不会经常出错，抛出ConcurrentModificationException异常，说我们在遍历的时候还在修改元素。</li>\n<li>这其实就是fail-fast机制~具体可参考博文：<a href=\"https://blog.csdn.net/panweiwei1994/article/details/77051261\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/panweiwei1994/article/details/77051261</a> </li>\n</ul>\n<p><strong>区别有三点：</strong></p>\n<ul>\n<li>Iterator的方法名比Enumeration更科学</li>\n<li>Iterator有fail-fast机制，比Enumeration更安全</li>\n<li>Iterator能够删除元素，Enumeration并不能删除元素</li>\n</ul>\n<h1 id=\"ListIterator有什么特点\">ListIterator有什么特点<a href=\"post/【java集合框架】-2-对比总结#ListIterator有什么特点\"></a></h1><ul>\n<li>ListIterator<strong>继承了</strong>Iterator接口，它用于<strong>遍历List集合的元素</strong>。</li>\n<li>ListIterator可以实现<strong>双向遍历,添加元素，设置元素</strong> </li>\n</ul>\n<h1 id=\"并发集合类是什么？\">并发集合类是什么？<a href=\"post/【java集合框架】-2-对比总结#并发集合类是什么？\"></a></h1><p>Java1.5并发包（java.util.concurrent）<strong>包含线程安全集合类，允许在迭代时修改集合</strong>。</p>\n<ul>\n<li>迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。</li>\n<li>一部分类为：<ul>\n<li>CopyOnWriteArrayList</li>\n<li>ConcurrentHashMap</li>\n<li>CopyOnWriteArraySet</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Java中HashMap的key值要是为类对象则该类需要满足什么条件？\">Java中HashMap的key值要是为类对象则该类需要满足什么条件？<a href=\"post/【java集合框架】-2-对比总结#Java中HashMap的key值要是为类对象则该类需要满足什么条件？\"></a></h1><p><strong>需要同时重写该类的hashCode()方法和它的equals()方法</strong>。</p>\n<ul>\n<li>从源码可以得知，在插入元素的时候是<strong>先算出该对象的hashCode</strong>。如果hashcode相等话的。那么表明该对象是存储在同一个位置上的。</li>\n<li>如果调用equals()方法，<strong>两个key相同</strong>，则<strong>替换元素</strong> </li>\n<li>如果调用equals()方法，<strong>两个key不相同</strong>，则说明该<strong>hashCode仅仅是碰巧相同</strong>，此时是散列冲突，将新增的元素放在桶子上</li>\n</ul>\n<p>一般来说，我们会认为：<strong>只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的</strong>！因为，Object底层比较的是两个对象的地址，而对我们开发来说这样的意义并不大~这也就为什么我们要重写<code>equals()</code>方法</p>\n<p>重写了equals()方法，就要重写hashCode()的方法。因为<strong>equals()认定了这两个对象相同</strong>，而<strong>同一个对象调用hashCode()方法时</strong>，是应该返回相同的值的！</p>\n<h1 id=\"与Java集合框架相关的有哪些最好的实践\">与Java集合框架相关的有哪些最好的实践<a href=\"post/【java集合框架】-2-对比总结#与Java集合框架相关的有哪些最好的实践\"></a></h1><ol>\n<li><strong>根据需要</strong>确定集合的类型。如果是单列的集合，我们考虑用Collection下的子接口ArrayList和Set。如果是映射，我们就考虑使用Map~</li>\n<li>确定完我们的集合类型，我们接下来<strong>确定使用该集合类型下的哪个子类</strong>~我认为可以简单分成几个步骤：<ul>\n<li>是否需要同步<ul>\n<li>去找线程安全的集合类使用</li>\n</ul>\n</li>\n<li>迭代时是否需要有序(插入顺序有序)<ul>\n<li>去找Linked双向列表结构的</li>\n</ul>\n</li>\n<li>是否需要排序(自然顺序或者手动排序)<ul>\n<li>去找Tree红黑树类型的(JDK1.8)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>估算存放集合的数据量有多大，无论是List还是Map，它们实现动态增长，都是有性能消耗的。在初始集合的时候给出一个<strong>合理的容量</strong>会减少动态增长时的消耗~</li>\n<li><strong>使用泛型</strong>，避免在运行时出现ClassCastException</li>\n<li>尽可能使用Collections工具类，或者获取只读、同步或空的集合，<strong>而非编写自己的实现</strong>。它将会提供代码重用性，它有着更好的稳定性和可维护性</li>\n</ol>\n<h1 id=\"ArrayList集合加入1万条数据，应该怎么提高效率\">ArrayList集合加入1万条数据，应该怎么提高效率<a href=\"post/【java集合框架】-2-对比总结#ArrayList集合加入1万条数据，应该怎么提高效率\"></a></h1><p>ArrayList的默认初始容量为10，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了10万条数据了，我们可以<strong>直接在初始化的时候就设置ArrayList的容量</strong>！</p>\n<p>这样就可以提高效率了~</p>\n<h1 id=\"关于集合存储null值\">关于集合存储null值<a href=\"post/【java集合框架】-2-对比总结#关于集合存储null值\"></a></h1><p><strong>|–Hashtable：</strong>底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。</p>\n<p><strong>|–HashMap：</strong>底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.</p>\n<h1 id=\"ArrayList扩容机制\">ArrayList扩容机制<a href=\"post/【java集合框架】-2-对比总结#ArrayList扩容机制\"></a></h1><p>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</p>\n<p>ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）。 JDk1.6版本时，扩容之后容量为 1.5 倍+1</p>\n<p>源码：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</span><br></pre></td></tr></table></div></figure>\n\n<p>向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p>\n<blockquote>\n<p>参考链接：<a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md\" target=\"_blank\" rel=\"noopener\">通过源码一步一步分析ArrayList 扩容机制</a></p>\n</blockquote>\n","prev":{"title":"【刨根问底】HashMap","link":"post/【刨根问底】HashMap"},"next":{"title":"【java集合框架】(1)基础","link":"post/【java集合框架】(1).基础"},"plink":"https://gmahsm.github.io/post/【java集合框架】-2-对比总结/","toc":[{"title":"List,Set,Map三者的区别？","id":"List-Set-Map三者的区别？","index":"1"},{"title":"List和Map的区别","id":"List和Map的区别","index":"2"},{"title":"ArrayList和Vector的区别？","id":"ArrayList和Vector的区别？","index":"3"},{"title":"为什么Vector过时了","id":"为什么Vector过时了","index":"4"},{"title":"Arraylist 与 LinkedList 区别","id":"Arraylist-与-LinkedList-区别","index":"5"},{"title":"HashMap和Hashtable的区别","id":"HashMap和Hashtable的区别","index":"6"},{"title":"Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()?","id":"Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals","index":"7"},{"title":"Collection和Collections的区别","id":"Collection和Collections的区别","index":"8"},{"title":"说出ArrayList,LinkedList的存储性能和特性","id":"说出ArrayList-LinkedList的存储性能和特性","index":"9","children":[{"title":"扩展：","id":"扩展：","index":"9.1"}]},{"title":"Enumeration和Iterator接口的区别","id":"Enumeration和Iterator接口的区别","index":"10"},{"title":"ListIterator有什么特点","id":"ListIterator有什么特点","index":"11"},{"title":"并发集合类是什么？","id":"并发集合类是什么？","index":"12"},{"title":"Java中HashMap的key值要是为类对象则该类需要满足什么条件？","id":"Java中HashMap的key值要是为类对象则该类需要满足什么条件？","index":"13"},{"title":"与Java集合框架相关的有哪些最好的实践","id":"与Java集合框架相关的有哪些最好的实践","index":"14"},{"title":"ArrayList集合加入1万条数据，应该怎么提高效率","id":"ArrayList集合加入1万条数据，应该怎么提高效率","index":"15"},{"title":"关于集合存储null值","id":"关于集合存储null值","index":"16"},{"title":"ArrayList扩容机制","id":"ArrayList扩容机制","index":"17"}],"reward":true,"copyright":{"custom":"copyright:自由转载-非商用-禁止演绎-保持署名"}}