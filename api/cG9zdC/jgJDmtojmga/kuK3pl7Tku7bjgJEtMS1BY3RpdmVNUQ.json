{"title":"【消息中间件】(1).ActiveMQ","date":"2019-08-08T02:35:14.000Z","thumbnail":null,"link":"post/【消息中间件】-1-ActiveMQ","tags":["activeMQ","消息中间件"],"categories":["奇客工具"],"updated":"2019-08-14T09:24:23.082Z","content":"<p><strong>什么是消息中间件？</strong></p>\n<p>就像快递代收点或者蜂巢。介于快递公司（操作系统）和收件人（应用程序）之间的产品。解决了<strong>送件人必须当面亲手将快递交给收件人</strong>的问题</p>\n<a id=\"more\"></a>\n\n<h1 id=\"消息中间件的组成\">消息中间件的组成<a href=\"post/【消息中间件】-1-ActiveMQ#消息中间件的组成\"></a></h1><ul>\n<li>Broker</li>\n</ul>\n<p>消息服务器，作为server提供消息核心服务</p>\n<ul>\n<li>Producer</li>\n</ul>\n<p>消息生产者，业务的发起方，负责生产消息传输给broker，</p>\n<ul>\n<li>Consumer</li>\n</ul>\n<p>消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</p>\n<ul>\n<li>Topic</li>\n</ul>\n<p>主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的       广播</p>\n<ul>\n<li>Queue</li>\n</ul>\n<p>队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</p>\n<ul>\n<li>Message</li>\n</ul>\n<p>消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</p>\n<h1 id=\"JMS\">JMS<a href=\"post/【消息中间件】-1-ActiveMQ#JMS\"></a></h1><p><strong>Java消息服务</strong>（<strong>Java Message Service</strong>，<strong>JMS</strong>）：是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。<br>       JMS本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。它类似JDBC(java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。</p>\n<h2 id=\"体系结构\">体系结构<a href=\"post/【消息中间件】-1-ActiveMQ#体系结构\"></a></h2><p><img src=\"https://i.loli.net/2019/08/07/CcQAE8XqsuKoF6D.jpg\" alt class=\"article-img\"></p>\n<h2 id=\"消息中间件模式分类\">消息中间件模式分类<a href=\"post/【消息中间件】-1-ActiveMQ#消息中间件模式分类\"></a></h2><ul>\n<li><p>点对点</p>\n<p>  PTP点对点:使用queue作为通信载体</p>\n<p>  <img src=\"https://i.loli.net/2019/08/07/jJqldvH5cayhiAW.jpg\" alt class=\"article-img\"></p>\n</li>\n</ul>\n<p>说明：<br>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。<br>消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p>\n<ul>\n<li><p>发布订阅</p>\n<p>  Pub/Sub发布订阅（广播）：使用topic作为通信载体 </p>\n<p>  <img src=\"https://i.loli.net/2019/08/07/YJev6IXDzLS8rqf.jpg\" alt class=\"article-img\"></p>\n</li>\n</ul>\n<p>说明：<br>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。</p>\n<p>queue实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。<br>topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到一个消息的拷贝。</p>\n<h2 id=\"5种消息体格式\">5种消息体格式<a href=\"post/【消息中间件】-1-ActiveMQ#5种消息体格式\"></a></h2><p>JMS API定义了5种消息体格式，可以使用不同形式发送接收数据，并可兼容现有的消息格式：比如</p>\n<ol>\n<li>TextMessage：String对象</li>\n<li>MapMessage：名/值对的集合，名为String对象，值类型可以是Java任何数据类型</li>\n<li>BytesMessage：字节流</li>\n<li>StreamMessage：java中的输入输出流</li>\n<li>ObjectMessage：Java中的可序列化对象</li>\n<li>Message：没有消息体，只有消息头和属性</li>\n</ol>\n<h1 id=\"为什么用\">为什么用<a href=\"post/【消息中间件】-1-ActiveMQ#为什么用\"></a></h1><p>核心的有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p>\n<h2 id=\"1-解耦\">1. 解耦<a href=\"post/【消息中间件】-1-ActiveMQ#1-解耦\"></a></h2><p>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</p>\n<p><img src=\"https://i.loli.net/2019/08/07/YOB49lNQyrPM3sK.jpg\" alt class=\"article-img\"></p>\n<p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p>\n<p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p>\n<p><img src=\"https://i.loli.net/2019/08/07/q6ACcnUzaB4O1EH.jpg\" alt class=\"article-img\"></p>\n<p><strong>总结</strong>：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p>\n<h2 id=\"2-异步\">2. 异步<a href=\"post/【消息中间件】-1-ActiveMQ#2-异步\"></a></h2><p>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p>\n<p><img src=\"https://i.loli.net/2019/08/07/gBeyFX8LE4TPu2Z.jpg\" alt class=\"article-img\"></p>\n<p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p>\n<p>如果<strong>使用 MQ</strong>，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p>\n<p><img src=\"https://i.loli.net/2019/08/07/aTGyUhS7FVmOCK1.jpg\" alt class=\"article-img\"></p>\n<h2 id=\"3-削峰\">3.削峰<a href=\"post/【消息中间件】-1-ActiveMQ#3-削峰\"></a></h2><p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p>\n<p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p>\n<p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p>\n<p><img src=\"https://i.loli.net/2019/08/07/pXK5RUjvhcVWndP.jpg\" alt class=\"article-img\"></p>\n<p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p>\n<p><img src=\"https://i.loli.net/2019/08/07/glpw9S27ZbBxd8V.jpg\" alt class=\"article-img\"></p>\n<p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p>\n<h1 id=\"有什么缺点\">有什么缺点<a href=\"post/【消息中间件】-1-ActiveMQ#有什么缺点\"></a></h1><h2 id=\"1-系统可用性降低\">1. 系统可用性降低<a href=\"post/【消息中间件】-1-ActiveMQ#1-系统可用性降低\"></a></h2><p>系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。</p>\n<h2 id=\"2-系统复杂性提高\">2. 系统复杂性提高<a href=\"post/【消息中间件】-1-ActiveMQ#2-系统复杂性提高\"></a></h2><p>硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已</p>\n<h2 id=\"3-一致性问题\">3. 一致性问题<a href=\"post/【消息中间件】-1-ActiveMQ#3-一致性问题\"></a></h2><p>A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。</p>\n<p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，用，还是得用的。。。</p>\n<h1 id=\"目前流行的消息队列优缺点对比\">目前流行的消息队列优缺点对比<a href=\"post/【消息中间件】-1-ActiveMQ#目前流行的消息队列优缺点对比\"></a></h1><div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ActiveMQ</th>\n<th>RabbitMQ</th>\n<th>RocketMQ</th>\n<th>Kafka</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单机吞吐量</td>\n<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>\n<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>\n<td>10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td>\n<td>10万级别，这是kafka最大的优点，就是吞吐量高。<br> 一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>\n</tr>\n<tr>\n<td>topic数量对吞吐量的影响</td>\n<td></td>\n<td></td>\n<td>topic可以达到几百，几千个的级别，<br>吞吐量会有较小幅度的下降,这是RocketMQ的一大优势，<br>在同等机器下，可以支撑大量的topic</td>\n<td>topic从几十个到几百个的时候，吞吐量会大幅度下降 <br>所以在同等机器下，kafka尽量保证topic数量不要过多。<br>如果要支撑大规模topic，需要增加更多的机器资源</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>ms级</td>\n<td>微秒级，这是rabbitmq的一大特点，延迟是最低的</td>\n<td>ms级</td>\n<td>延迟在ms级以内</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>高，基于主从架构实现高可用性</td>\n<td>高，基于主从架构实现高可用性</td>\n<td>非常高，分布式架构</td>\n<td>非常高，kafka是分布式的，一个数据多个副本，<br>少数机器宕机，不会丢失数据，不会导致不可用</td>\n</tr>\n<tr>\n<td>消息可靠性</td>\n<td>有较低的概率丢失数据</td>\n<td></td>\n<td>经过参数优化配置，可以做到0丢失</td>\n<td>经过参数优化配置，消息可以做到0丢失</td>\n</tr>\n<tr>\n<td>功能支持</td>\n<td>MQ领域的功能极其完备</td>\n<td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td>\n<td>MQ功能较为完善，还是分布式的，扩展性好</td>\n<td>功能较为简单，主要支持简单的MQ功能，<br>在大数据领域的实时计算以及日志采集被大规模使用，<br>是事实上的标准</td>\n</tr>\n</tbody></table></div></div>\n<p>优劣势总结：</p>\n<ul>\n<li><p>ActiveMQ：非常成熟，功能强大，在业内大量的公司以及项目中都有应用 偶尔会有较低概率丢失消息 而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本 而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用</p>\n</li>\n<li><p>RabbitMQ：erlang语言开发，性能极其好，延时很低； 吞吐量到万级，MQ功能比较完备 而且开源提供的管理界面非常棒，用起来很好用 社区相对比较活跃，几乎每个月都发布几个版本分 在国内一些互联网公司近几年用rabbitmq也比较多一些 但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。 而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。 而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</p>\n</li>\n<li><p>接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障 日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景 而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码 还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的</p>\n</li>\n<li><p>kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展 同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量 而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略 这个特性天然适合大数据实时计算以及日志收集</p>\n</li>\n</ul>\n<h1 id=\"怎么用\">怎么用<a href=\"post/【消息中间件】-1-ActiveMQ#怎么用\"></a></h1><p>更新中…</p>\n<h1 id=\"参考-感谢\">参考-感谢<a href=\"post/【消息中间件】-1-ActiveMQ#参考-感谢\"></a></h1><p><a href=\"https://www.jianshu.com/p/eaafb1581e55\" target=\"_blank\" rel=\"noopener\">消息中间件面试题</a></p>\n<p><a href=\"https://blog.csdn.net/wqc19920906/article/details/82193316\" target=\"_blank\" rel=\"noopener\">MQ详解及四大MQ比较</a></p>\n<p><a href=\"https://blog.csdn.net/lchpersonal521/article/details/83989933\" target=\"_blank\" rel=\"noopener\">MQ学习笔记</a></p>\n","prev":{"title":"【java集合框架】(1)基础","link":"post/【java集合框架】(1).基础"},"next":{"title":"【科学上网】Vultr+Shadowsocks","link":"post/【科学上网】Vultr-Shadowsocks"},"plink":"https://gmahsm.github.io/post/【消息中间件】-1-ActiveMQ/","toc":[{"title":"消息中间件的组成","id":"消息中间件的组成","index":"1"},{"title":"JMS","id":"JMS","index":"2","children":[{"title":"体系结构","id":"体系结构","index":"2.1"},{"title":"消息中间件模式分类","id":"消息中间件模式分类","index":"2.2"},{"title":"5种消息体格式","id":"5种消息体格式","index":"2.3"}]},{"title":"为什么用","id":"为什么用","index":"3","children":[{"title":"1. 解耦","id":"1-解耦","index":"3.1"},{"title":"2. 异步","id":"2-异步","index":"3.2"},{"title":"3.削峰","id":"3-削峰","index":"3.3"}]},{"title":"有什么缺点","id":"有什么缺点","index":"4","children":[{"title":"1. 系统可用性降低","id":"1-系统可用性降低","index":"4.1"},{"title":"2. 系统复杂性提高","id":"2-系统复杂性提高","index":"4.2"},{"title":"3. 一致性问题","id":"3-一致性问题","index":"4.3"}]},{"title":"目前流行的消息队列优缺点对比","id":"目前流行的消息队列优缺点对比","index":"5"},{"title":"怎么用","id":"怎么用","index":"6"},{"title":"参考-感谢","id":"参考-感谢","index":"7"}],"reward":true,"copyright":{"custom":"copyright:自由转载-非商用-禁止演绎-保持署名"}}