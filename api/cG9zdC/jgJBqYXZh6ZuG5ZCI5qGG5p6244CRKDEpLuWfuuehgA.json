{"title":"【java集合框架】(1)基础","date":"2019-08-19T17:02:37.000Z","thumbnail":null,"link":"post/【java集合框架】(1).基础","tags":["集合"],"categories":["奇客工具"],"updated":"2019-08-19T17:05:34.976Z","content":"<p>Java中的集合框架定义了一套规范，用来表示、操作集合，使具体操作与实现细节解耦。</p>\n<p>其实可以把一个集合看成一个微型数据库，操作不外乎“增删改查”四种操作，我们在学习使用一个具体的集合类时，需要把这四个操作的<code>空间复杂度</code>弄清楚。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"集合概述\">集合概述<a href=\"post/【java集合框架】(1).基础#集合概述\"></a></h1><p>集合是java中提供的一种容器，可以用来存储多个数据。java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。</p>\n<p><strong>集合和数组既然都是容器，它们有啥区别呢？</strong></p>\n<ul>\n<li><p>长度区别</p>\n<p>  ​    数组的长度固定</p>\n<p>  ​    集合的长度可变</p>\n</li>\n<li><p>内容不同</p>\n</li>\n</ul>\n<p>　　　　数组存储的是同一种类型的元素</p>\n<p>　　　　集合可以存储不同类型的元素</p>\n<ul>\n<li>存储元素的数据类型不同</li>\n</ul>\n<p>　　　　数组可以存储基本数据类型，也可以存储引用数据类型（引用数据类型存储的是地址值）。</p>\n<p>　　　　集合只能存储引用数据类型（也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象）。</p>\n<hr>\n<p><strong>Java集合类库构成了集合类的框架，包含了大量的接口，抽象类，框架图如下所示：</strong></p>\n<p><img src=\"https://i.loli.net/2019/08/19/mWsO1L3wQNrGf2u.png\" alt class=\"article-img\"></p>\n<p>从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等</p>\n<p><strong>集合框架体系</strong></p>\n<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>\n<ul>\n<li><strong>接口</strong>：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li>\n<li><strong>实现（类）</strong>：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li>\n<li><strong>算法</strong>：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现</li>\n</ul>\n<h1 id=\"迭代器接口：Iterator\">迭代器接口：Iterator<a href=\"post/【java集合框架】(1).基础#迭代器接口：Iterator\"></a></h1><p><code>Iterator</code>接口主要用来遍历集合对象中的元素</p>\n<h2 id=\"原理\">原理<a href=\"post/【java集合框架】(1).基础#原理\"></a></h2><p><img src=\"https://i.loli.net/2019/08/19/DJ9hSXmZK8tcs4g.jpg\" alt class=\"article-img\"></p>\n<h2 id=\"常用方法：\">常用方法：<a href=\"post/【java集合框架】(1).基础#常用方法：\"></a></h2><ul>\n<li><code>E next()</code>：返回将要访问的下一个对象</li>\n<li><code>boolean hasNext()</code>：如果存在可访问的元素，返回true</li>\n<li><code>void remove()</code>：删除上次访问的对象，必须紧跟在访问一个元素之后执行</li>\n</ul>\n<h2 id=\"遍历元素\">遍历元素<a href=\"post/【java集合框架】(1).基础#遍历元素\"></a></h2><p>通过反复调用<code>next</code>方法，可以逐个访问集合中的每个元素，如果到达了集合的末尾，<code>next</code>方法将抛出一个<code>NoSuchElementException</code>，因此在调用<code>next</code>方法之前需要调用<code>hasNext</code>方法判断是否到达集合末尾。使用方法如下：</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection&lt;String&gt; c = ...</span><br><span class=\"line\">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(iter.hasNext())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    String ele = iter.next();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>从<code>Java JDK1.5</code>之后，可以用for循环来执行上述循环操作了，更加简洁，代码如下：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(String ele : c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"删除元素\">删除元素<a href=\"post/【java集合框架】(1).基础#删除元素\"></a></h2><p><code>Iterator</code>接口的<code>remove</code>方法删除上次调用<code>next</code>方法返回的元素，与遍历元素类似，删除某元素前，需要判断该元素是否有意义。正确的使用方法如下：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection&lt;String&gt; c = ...</span><br><span class=\"line\">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class=\"line\">iter.next();</span><br><span class=\"line\">iter.remove();</span><br></pre></td></tr></table></div></figure>\n\n<p>可以看到先调用<code>next</code>方法返回想要删除的元素，再删除之。如果上次访问之后，集合已经发生变化，再调用<code>remove</code>方法，将抛出一个<code>IllegalStateException</code>。<br>以下的使用方法都是错误的：</p>\n<ul>\n<li><p>没有调用<code>next</code>方法</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class=\"line\">iter.remove();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用一次<code>next</code>方法，删除连续两个元素</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class=\"line\">iter.next();</span><br><span class=\"line\">iter.remove();</span><br><span class=\"line\">iter.remove();</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<blockquote>\n<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>\n</blockquote>\n<h1 id=\"Collection\">Collection<a href=\"post/【java集合框架】(1).基础#Collection\"></a></h1><p>Collection是所有<strong>单列集合</strong>的父接口，Collection 接口存储一组无序，可重复的5对象。</p>\n<p>在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法(部分)如下：</p>\n<h2 id=\"常用方法\">常用方法<a href=\"post/【java集合框架】(1).基础#常用方法\"></a></h2><div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th align=\"center\">返回值</th>\n<th>方法和描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">boolean</td>\n<td>add(E e)`<br>把给定的对象添加到当前集合中 。</td>\n</tr>\n<tr>\n<td align=\"center\">void</td>\n<td><code>clear()</code><br>清空集合中所有的元素。</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td><code>remove(E e)</code><br>把给定的对象在当前集合中删除。</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td><code>contains(E e)</code><br>判断当前集合中是否包含给定的对象。</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td><code>isEmpty()</code><br>判断当前集合是否为空。</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td><code>size()</code><br>返回集合中元素的个数。</td>\n</tr>\n<tr>\n<td align=\"center\">Object[]</td>\n<td><code>toArray()</code><br>把集合中的元素，存储到数组中。</td>\n</tr>\n</tbody></table></div></div>\n<h2 id=\"List集合\">List集合<a href=\"post/【java集合框架】(1).基础#List集合\"></a></h2><p>有序(指存储和取出元素的顺序一致)、存储元素可重复</p>\n<h3 id=\"List集合特有方法\">List集合特有方法<a href=\"post/【java集合框架】(1).基础#List集合特有方法\"></a></h3><p>因为list集合是有序的，所以它的特有方法都和元素的索引有关</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th align=\"center\">返回值</th>\n<th>方法和描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>void</code></td>\n<td><code>add(int index, E element)</code>  <br>将指定的元素插入此列表中的指定位置（可选操作）。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>boolean</code></td>\n<td><code>addAll(int index,  Collection&lt;? extends E&gt; c)</code> <br> 将指定集合中的所有元素插入到此列表中的指定位置（可选操作）。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>E</code></td>\n<td><code>get(int index)</code>  <br>返回此列表中指定位置的元素。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>int</code></td>\n<td><code>indexOf(Object o)</code><br>  返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>int</code></td>\n<td><code>lastIndexOf(Object o)</code> <br> 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>ListIterator&lt;E&gt;</code></td>\n<td><code>listIterator()</code>   <br>返回列表中的列表迭代器（按适当的顺序）。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>ListIterator&lt;E&gt;</code></td>\n<td><code>listIterator(int index)</code>  <br> 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>E</code></td>\n<td><code>remove(int index)</code>  <br> 删除该列表中指定位置的元素（可选操作）。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>E</code></td>\n<td><code>set(int index, E element)</code>  <br>用指定的元素（可选操作）替换此列表中指定位置的元素。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>List&lt;E&gt;</code></td>\n<td><code>subList(int fromIndex,  int toIndex)</code>  <br>返回此列表中指定的 <code>fromIndex</code> （含）和 <code>toIndex</code>之间的视图。</td>\n</tr>\n</tbody></table></div></div>\n<h3 id=\"List集合的子类\">List集合的子类<a href=\"post/【java集合框架】(1).基础#List集合的子类\"></a></h3><p>List集合有ArrayList、Vector和LinkedList三个常用子类。</p>\n<h3 id=\"List集合的子类对比\">List集合的子类对比:<a href=\"post/【java集合框架】(1).基础#List集合的子类对比\"></a></h3><p>ArrayList的底层数据结构是数组，查询快，增删慢，线程不安全，效率高</p>\n<p>Vector的底层数据结构是数组，查询快，增删慢，线程安全，效率低</p>\n<p>LinkedList的底层数据结构是链表，查询慢，增删快。线程不安全，效率高</p>\n<p><strong>Vector的特有方法：</strong></p>\n<ul>\n<li>添加功能<ul>\n<li>public void addElement(Object obj)</li>\n</ul>\n</li>\n<li>获取功能<ul>\n<li>public Object elementAt(int index)</li>\n<li>public Enumeration elements()</li>\n</ul>\n</li>\n</ul>\n<p><strong>LinkedList的特有方法：</strong></p>\n<ul>\n<li>添加功能<ul>\n<li>public void addFirst(Object obj)</li>\n<li>public void addLast(Object obj)</li>\n</ul>\n</li>\n<li>获取功能<ul>\n<li>public Object getFirst()</li>\n<li>public Object getLast()</li>\n</ul>\n</li>\n<li>删除功能<ul>\n<li>public Object removeFirst()</li>\n<li>public Object removeLast()</li>\n</ul>\n</li>\n</ul>\n<p>public E removeLast() :移除并返回此列表的后一个元素。 </p>\n<p>public E pop() :从此列表所表示的堆栈处弹出一个元素。</p>\n<p>public void push(E e) :将元素推入此列表所表示的堆栈。 </p>\n<h2 id=\"Set集合\">Set集合<a href=\"post/【java集合框架】(1).基础#Set集合\"></a></h2><p>Set集合与Collection集合基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同，</p>\n<p>无序(指元素的存储和取出顺序不一致)、存储元素不可重复</p>\n<h3 id=\"Set集合的子类\">Set集合的子类<a href=\"post/【java集合框架】(1).基础#Set集合的子类\"></a></h3><p>Set集合有HashSet和TreeSet两个常用子类。HashSet类有一个子类LinkedHashSet</p>\n<h3 id=\"Set集合子类对比\">Set集合子类对比<a href=\"post/【java集合框架】(1).基础#Set集合子类对比\"></a></h3><p>HashSet的底层数据结构是<strong>哈希表</strong>，存储无序，线程不安全，元素值可以是null</p>\n<ul>\n<li>HashSet是基于HashMap实现的</li>\n</ul>\n<p>TreeSet的底层数据结构是<strong>红黑树</strong>(是一种自平衡的二叉树)，存储有序，线程不安全，性能较差</p>\n<ul>\n<li>TreeSet是基于TreeMap实现的</li>\n</ul>\n<p>LinkedHashSet的底层数据结构由<strong>链表和哈希表</strong>组成，存储元素的特点是有序、唯一</p>\n<ul>\n<li>由链表保证元素有序，由哈希表保证元素唯一。</li>\n</ul>\n<h3 id=\"HashSet\">HashSet<a href=\"post/【java集合框架】(1).基础#HashSet\"></a></h3><ul>\n<li><strong>HashSet结构</strong></li>\n</ul>\n<p><img src=\"https://i.loli.net/2019/08/19/fFLJzG516V4pqwd.png\" alt class=\"article-img\"></p>\n<ul>\n<li><p><strong>HashSet如何保证元素唯一性的原理：</strong></p>\n<p>  <img src=\"https://i.loli.net/2019/08/19/9LOebWmAKS1g3RU.png\" alt class=\"article-img\"></p>\n<blockquote>\n<p>因为在java源码中，equals()是在Hash值相同的时候才能调用到equals()，所以一定要重写HashCode()，否则Hash值都不一样也永远不可能进入到equals()中去。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"TreeSet\">TreeSet<a href=\"post/【java集合框架】(1).基础#TreeSet\"></a></h3><p>TreeSet类底层数据结构是红黑树(是一种自平衡的二叉树)。</p>\n<ul>\n<li><p><strong>TreeSet类如何保证元素唯一性呢?</strong></p>\n<p>  ​    根据比较的返回值是否是0来决定</p>\n</li>\n<li><p><strong>TreeSet类如何保证元素的排序呢?</strong></p>\n<p>  a：自然排序(元素具备比较性)</p>\n<p>  ​    让元素所属的类实现Comparable接口</p>\n<p>  b：比较器排序(集合具备比较性)</p>\n<p>  ​    让集合接收一个Comparator的实现类对象</p>\n</li>\n</ul>\n<blockquote>\n<p>参考：<a href=\"https://jokerlinisty.iteye.com/blog/2189109\" target=\"_blank\" rel=\"noopener\">TreeSet集合如何保持集合中的元素有序</a></p>\n</blockquote>\n<h3 id=\"LinkedHashSet\">LinkedHashSet<a href=\"post/【java集合框架】(1).基础#LinkedHashSet\"></a></h3><p>LinkedHashMap 较之 HashMap 内部多维护了一个双向链表用来维护元素的添加顺序。</p>\n<h2 id=\"Map集合\">Map集合<a href=\"post/【java集合框架】(1).基础#Map集合\"></a></h2><p><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</p>\n<p><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</p>\n<p>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</p>\n<p><img src=\"https://i.loli.net/2019/08/20/JD8ng54cQOGS6sp.png\" alt class=\"article-img\"></p>\n<h3 id=\"常用方法-1\">常用方法<a href=\"post/【java集合框架】(1).基础#常用方法-1\"></a></h3><div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th align=\"center\">返回值</th>\n<th>方法和描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">V</td>\n<td><code>put(K key, V value)</code><br>把指定的键与指定的值添加到Map集合中。</td>\n</tr>\n<tr>\n<td align=\"center\">V</td>\n<td><code>remove(Object key)</code><br>把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</td>\n</tr>\n<tr>\n<td align=\"center\">V</td>\n<td><code>get(Object key)</code> <br>根据指定的键，在Map集合中获取对应的值。</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td><code>containsKey(Object key)</code> <br>判断集合中是否包含指定的键。</td>\n</tr>\n<tr>\n<td align=\"center\">Set<k></k></td>\n<td><code>keySet()</code><br>获取Map集合中所有的键，存储到Set集合中。</td>\n</tr>\n<tr>\n<td align=\"center\">Set&lt;Map.Entry&lt;K,V&gt;&gt;</td>\n<td><code>entrySet()</code><br> 获取到Map集合中所有的键值对对象的集合(Set集合)</td>\n</tr>\n</tbody></table></div></div>\n<blockquote>\n<p>tips:</p>\n<p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p>\n<p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</p>\n</blockquote>\n<h3 id=\"有关于-map-entrySet-和-keySet\">有关于 map.entrySet() 和 keySet():<a href=\"post/【java集合框架】(1).基础#有关于-map-entrySet-和-keySet\"></a></h3><p>1、如果遍历 hashMap() 时 entrySet() 方法是将 key 和 value 全部取出来,所以性能开销是可以预计的, 而  keySet() 方法进行遍历的时候是根据取出的 key 值去查询对应的 value 值, 所以如果 key 值是比较简单的结构(如  1,2,3…)的话性能消耗上是比 entrySet() 方法低, 但随着 key 值得复杂度提高 entrySet() 的优势就会显露出来。</p>\n<p>2、综合比较在只遍历 key 的时候使用 keySet(), 在只遍历 value 的是使用 values() 方法, 在遍历 key-value 的时候使用 entrySet() 是比较合理的选择。</p>\n<p>3、如果遍历 TreeMap 的时候, 不同于 HashMap 在遍历 ThreeMap 的 key-value 时候务必使用  entrySet() 它要远远高于其他两个的性能, 同样只遍历 key 的时候使用 keySet(), 在只遍历 value 的是使用  values() 方法对于 TreeMap 也同样适用。</p>\n<blockquote>\n<p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p>\n</blockquote>\n<h3 id=\"HashMap\">HashMap<a href=\"post/【java集合框架】(1).基础#HashMap\"></a></h3><p>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</p>\n<h3 id=\"LinkedHashMap\">LinkedHashMap<a href=\"post/【java集合框架】(1).基础#LinkedHashMap\"></a></h3><p>HashMap下面的一个子类。它是链表和哈希表组合的一个数据存储结构。保证了数据的有序</p>\n","next":{"title":"【消息中间件】(1).ActiveMQ","link":"post/【消息中间件】-1-ActiveMQ"},"plink":"https://gmahsm.github.io/post/【java集合框架】(1).基础/","toc":[{"title":"集合概述","id":"集合概述","index":"1"},{"title":"迭代器接口：Iterator","id":"迭代器接口：Iterator","index":"2","children":[{"title":"原理","id":"原理","index":"2.1"},{"title":"常用方法：","id":"常用方法：","index":"2.2"},{"title":"遍历元素","id":"遍历元素","index":"2.3"},{"title":"删除元素","id":"删除元素","index":"2.4"}]},{"title":"Collection","id":"Collection","index":"3","children":[{"title":"常用方法","id":"常用方法","index":"3.1"},{"title":"List集合","id":"List集合","index":"3.2","children":[{"title":"List集合特有方法","id":"List集合特有方法","index":"3.2.1"},{"title":"List集合的子类","id":"List集合的子类","index":"3.2.2"},{"title":"List集合的子类对比:","id":"List集合的子类对比","index":"3.2.3"}]},{"title":"Set集合","id":"Set集合","index":"3.3","children":[{"title":"Set集合的子类","id":"Set集合的子类","index":"3.3.1"},{"title":"Set集合子类对比","id":"Set集合子类对比","index":"3.3.2"},{"title":"HashSet","id":"HashSet","index":"3.3.3"},{"title":"TreeSet","id":"TreeSet","index":"3.3.4"},{"title":"LinkedHashSet","id":"LinkedHashSet","index":"3.3.5"}]},{"title":"Map集合","id":"Map集合","index":"3.4","children":[{"title":"常用方法","id":"常用方法-1","index":"3.4.1"},{"title":"有关于 map.entrySet() 和 keySet():","id":"有关于-map-entrySet-和-keySet","index":"3.4.2"},{"title":"HashMap","id":"HashMap","index":"3.4.3"},{"title":"LinkedHashMap","id":"LinkedHashMap","index":"3.4.4"}]}]}],"reward":true,"copyright":{"custom":"copyright:自由转载-非商用-禁止演绎-保持署名"}}