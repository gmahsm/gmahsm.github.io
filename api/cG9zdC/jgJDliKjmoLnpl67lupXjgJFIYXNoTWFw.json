{"title":"【刨根问底】HashMap","date":"2019-08-26T17:04:51.000Z","thumbnail":null,"link":"post/【刨根问底】HashMap","tags":["hashmap","刨根问底","集合框架"],"categories":["奇客工具"],"updated":"2019-08-26T17:07:54.493Z","content":"<blockquote>\n<p>首先复习一下<a href=\"https://zhidao.baidu.com/question/206460065.html?fr=iks&word=%B6%FE%BD%F8%D6%C6%D6%D0%26%B2%D9%D7%F7&ie=gbk\" target=\"_blank\" rel=\"noopener\">二进制位运算</a>，下面会用到</p>\n</blockquote>\n<h1 id=\"hashmap简述：\">hashmap简述：<a href=\"post/【刨根问底】HashMap#hashmap简述：\"></a></h1><ul>\n<li>底层数据结构：数组+红黑树+链表（）</li>\n<li>默认初始容量16；给定容量初始值的话，容量为大于或等于给定值的最小2^n^（如给定初始值是1000或1024，那么容量是1024）</li>\n<li>最大容量2^31^。(源码是<code>1&lt;&lt;30</code>)，</li>\n<li>负载因子默认0.75,</li>\n<li>极限值12，就是说当容量超过12（16*0.75）时，hashmap扩容，</li>\n<li>扩容后容量是原来的2倍</li>\n<li>链表长度&gt;=8转换为红黑树，长度&lt;=6退化成链表</li>\n<li>HashMap三种遍历方式</li>\n</ul>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMapExam</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">15</span>; i++) &#123;</span><br><span class=\"line\">            map.put(i, <span class=\"keyword\">new</span> String(<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[]&#123;(<span class=\"keyword\">char</span>) (<span class=\"string\">'A'</span>+ i)&#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"======keySet=======\"</span>);</span><br><span class=\"line\">        Set&lt;Integer&gt; set = map.keySet();</span><br><span class=\"line\">        Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">            System.out.println(iterator.next());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"======values=======\"</span>);</span><br><span class=\"line\">        Collection&lt;String&gt; values = map.values();</span><br><span class=\"line\">        Iterator&lt;String&gt; stringIterator=values.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (stringIterator.hasNext()) &#123;</span><br><span class=\"line\">            System.out.println(stringIterator.next());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"======entrySet=======\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">            System.out.println(entry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"原理图：\">原理图：<a href=\"post/【刨根问底】HashMap#原理图：\"></a></h1><p><img src=\"https://i.loli.net/2019/08/26/V9DoIixcS53Z7Mv.jpg\" alt class=\"article-img\"></p>\n<p>HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。<br>只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！</p>\n<h1 id=\"为什么用数组-链表？\">为什么用数组+链表？<a href=\"post/【刨根问底】HashMap#为什么用数组-链表？\"></a></h1><p>数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到.<br>链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</p>\n<blockquote>\n<p>这里的hash值并不是指hashcode，而是将hashcode高低十六位异或过的。后面会解释</p>\n</blockquote>\n<h1 id=\"其它解决hash冲突的方法？\">其它解决hash冲突的方法？<a href=\"post/【刨根问底】HashMap#其它解决hash冲突的方法？\"></a></h1><ul>\n<li>开放定址法/再散列法</li>\n<li>再哈希法</li>\n</ul>\n<blockquote>\n<p>细节内容可以跳转<a href=\"https://www.cnblogs.com/wuchaodzxx/p/7396599.html\" target=\"_blank\" rel=\"noopener\">解决哈希冲突的方法</a></p>\n</blockquote>\n<h1 id=\"用LinkedList代替数组结构可以么\">用LinkedList代替数组结构可以么?<a href=\"post/【刨根问底】HashMap#用LinkedList代替数组结构可以么\"></a></h1><p>是可以的。</p>\n<p><strong>既然是可以的,为什么HashMap不用LinkedList,而选用数组?</strong><br>因为用数组效率最高！<br>在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</p>\n<p><strong>那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList?</strong><br>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高，而ArrayList的扩容机制是1.5倍扩容</p>\n<h1 id=\"为什么HashMap长度是2的次幂\">为什么HashMap长度是2的次幂?<a href=\"post/【刨根问底】HashMap#为什么HashMap长度是2的次幂\"></a></h1><p>为了存取高效，减少碰撞，使元素尽量分布均匀</p>\n<ul>\n<li><p>实现分布均匀</p>\n<ul>\n<li>hash：hashmap中元素在table中的index是由key的hash值决定的（并不是直接使用key的hash值，至于为什么下面会说到），hash值是int数据类型，范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的，所以这个散列值是不能直接拿来用的</li>\n<li>取模(%)：设定一个数组长度，然后用hash对数组长度取模。<code>hash%length</code></li>\n</ul>\n</li>\n<li><p>均匀分布且高效</p>\n<ul>\n<li><p>二进制位操作：位移运算比取模这类运算快，所以优化成<code>hash&amp;(length-1)</code></p>\n<p>  也就是说<code>hash%length等价于hash&amp;(length-1)</code>。</p>\n<p>  <strong>与运算是怎么保证数据均匀分布的？</strong></p>\n<p>  二进制中2的n次方实际就是1后面n个0，2的n次方-1，实际就是n个1</p>\n<p>  <img src=\"https://i.loli.net/2019/08/26/tQJVB197LhiFdpN.png\" alt class=\"article-img\"></p>\n<p>  如果容积是2的n次方，那么<code>length-1</code>的二进制就是n个1 ，那么<code>hash&amp;(length-1)</code>也就是hash和1111……1111111进行与运算，最开始有复习二进制位运算，与运算可以取一个数中指定位</p>\n<p>  <img src=\"https://i.loli.net/2019/08/26/ysrNDH146xfeXmR.png\" alt class=\"article-img\"></p>\n<p>  这样<code>hash&amp;(length-1)</code>就保证了数据原来的分布状态，只要hash是分布均匀的，那么数据就是分布均匀的</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"如何保证创建的hashmap容量是2的幂次方？\">如何保证创建的hashmap容量是2的幂次方？<a href=\"post/【刨根问底】HashMap#如何保证创建的hashmap容量是2的幂次方？\"></a></h1><figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *给定了容量初始值创建hashmap时，此方法保证创建的返回给定目标容量的2次幂</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>如上面源码中tableSizeFor（int cap)方法。进行位运算。假如我指定容量是1024，忽略<code>int n = cap - 1</code>,那么操作如下</p>\n<p><img src=\"https://i.loli.net/2019/08/26/gNi2E64k8QlFVHC.png\" alt class=\"article-img\"></p>\n<p>结果是：给定值是1024，返回值是n+1=2048。我期望是:：给定值是2^n^时，hashmap容量等于给定值，现在的结果不符合期望。</p>\n<p>所以在或运算之前先将给定值-1，避免给定值恰巧是2^n^时，hashmap容量等于给定值*2</p>\n<h1 id=\"为什么为什么要先高16位异或低16位再取模运算\">为什么为什么要先高16位异或低16位再取模运算?<a href=\"post/【刨根问底】HashMap#为什么为什么要先高16位异或低16位再取模运算\"></a></h1><figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*计算key的hash值</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>若hash值只用自身的hashcode,那么后面计算元素在数组中位置的时候，只有hash的低位与（length-1）做&amp;操作.这样会带来哈希冲突的风险。增加这个异或操作（扰动函数）之后，hash的高位参与进来，降低了hash冲突的几率</p>\n<h1 id=\"hashmap中put元素的过程\">hashmap中put元素的过程?<a href=\"post/【刨根问底】HashMap#hashmap中put元素的过程\"></a></h1><p>对key的hashCode()做hash运算，计算index;<br>如果没碰撞直接放到bucket里；<br>如果碰撞了，以链表的形式存在buckets后；<br>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树(JDK1.8中的改动)；<br>如果节点已经存在就替换old value(保证key的唯一性)<br>如果bucket满了(超过load factor*current capacity)，就要resize。</p>\n<h1 id=\"hashmap中get元素的过程\">hashmap中get元素的过程?<a href=\"post/【刨根问底】HashMap#hashmap中get元素的过程\"></a></h1><p>对key的hashCode()做hash运算，计算index;<br>如果在bucket里的第一个节点里直接命中，则直接返回；<br>如果有冲突，则通过key.equals(k)去查找对应的Entry;</p>\n<ul>\n<li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li>\n<li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li>\n</ul>\n<h1 id=\"你还知道哪些hash算法？\">你还知道哪些hash算法？<a href=\"post/【刨根问底】HashMap#你还知道哪些hash算法？\"></a></h1><p>先说一下hash算法干嘛的，Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。<br>比较出名的有MurmurHash、MD4、MD5等等</p>\n<h1 id=\"参考-感谢\">参考-感谢<a href=\"post/【刨根问底】HashMap#参考-感谢\"></a></h1><p><a href=\"https://cloud.tencent.com/developer/article/1391162\" target=\"_blank\" rel=\"noopener\">hashmap源码解析</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?src=11&timestamp=1566782961&ver=1813&signature=PV1RSC5RiIrapq22LpCTp1OoJfz6LKpNlLGVjXGmaqlhzLZYFVXVOS8-zlhiz-qB1aZKOpZBPHAPQjFo0jUT8COhhIPbKe2L2wXcv2vYmYRvEpxXL-nB4YgPWcJYNHhL&new=1\" target=\"_blank\" rel=\"noopener\">hashmap面试专题</a></p>\n<p><a href=\"https://blog.csdn.net/qq_37939251/article/details/83795353\" target=\"_blank\" rel=\"noopener\">数组的最大长度</a></p>\n","next":{"title":"【java集合框架】(2)对比总结","link":"post/【java集合框架】-2-对比总结"},"plink":"https://gmahsm.github.io/post/【刨根问底】HashMap/","toc":[{"title":"hashmap简述：","id":"hashmap简述：","index":"1"},{"title":"原理图：","id":"原理图：","index":"2"},{"title":"为什么用数组+链表？","id":"为什么用数组-链表？","index":"3"},{"title":"其它解决hash冲突的方法？","id":"其它解决hash冲突的方法？","index":"4"},{"title":"用LinkedList代替数组结构可以么?","id":"用LinkedList代替数组结构可以么","index":"5"},{"title":"为什么HashMap长度是2的次幂?","id":"为什么HashMap长度是2的次幂","index":"6"},{"title":"如何保证创建的hashmap容量是2的幂次方？","id":"如何保证创建的hashmap容量是2的幂次方？","index":"7"},{"title":"为什么为什么要先高16位异或低16位再取模运算?","id":"为什么为什么要先高16位异或低16位再取模运算","index":"8"},{"title":"hashmap中put元素的过程?","id":"hashmap中put元素的过程","index":"9"},{"title":"hashmap中get元素的过程?","id":"hashmap中get元素的过程","index":"10"},{"title":"你还知道哪些hash算法？","id":"你还知道哪些hash算法？","index":"11"},{"title":"参考-感谢","id":"参考-感谢","index":"12"}],"reward":true,"copyright":{"custom":"copyright:自由转载-非商用-禁止演绎-保持署名"}}